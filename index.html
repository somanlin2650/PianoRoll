<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PianoRoll Studio | Professional Web MIDI Editor</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            overflow: hidden;
            user-select: none;
        }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        .piano-row {
            position: absolute;
            left: 0;
            width: 100%;
            box-sizing: border-box;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
        }

        .key-base {
            background: #fcfcfc;
            width: 100%;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
            border-right: 1px solid #ccc;
        }
        .key-base:hover { background: #eee; }

        .black-key {
            position: absolute;
            left: 0;
            top: 2px;
            height: calc(100% - 4px);
            width: 60%;
            background: linear-gradient(to bottom, #333, #000, #333);
            z-index: 10;
            border-radius: 0 3px 3px 0;
            box-shadow: 2px 2px 3px rgba(0,0,0,0.6);
            border: 1px solid #000;
        }
        .black-key:active {
            background: #222;
            width: 58%;
        }

        .key-divider {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 1px;
            background: #999;
            z-index: 5;
        }
        .key-divider-partial {
            position: absolute;
            right: 0;
            width: 40%;
            top: 50%;
            height: 1px;
            background: #ccc;
            z-index: 5;
        }

        .key-label {
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            color: #777;
            z-index: 15;
            pointer-events: none;
            font-weight: bold;
            font-size: 9px;
        }

        .piano-row.active .key-base { background: #4fd1c5 !important; }
        .piano-row.active .black-key { background: #2c7a7b !important; }

        #keys-viewport {
            position: relative;
            overflow: hidden;
            flex: 1;
            background: #1e1e1e;
        }
        
        #keys-list {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
        }

        .loader {
            border: 3px solid #333;
            border-top: 3px solid #4fd1c5;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .selection-rect {
            position: absolute;
            background: rgba(45, 212, 191, 0.2);
            border: 1px solid #2dd4bf;
            display: none;
            pointer-events: none;
            z-index: 100;
        }

        #velocity-lane {
            position: relative;
            background: #18181b;
            border-top: 1px solid #27272a;
        }
        #velocity-resize-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            cursor: row-resize;
            background: linear-gradient(to bottom, #27272a, transparent);
            z-index: 10;
        }
        #velocity-canvas {
            position: absolute;
            left: 0;
            top: 4px;
            right: 0;
            bottom: 0;
        }

        .metronome-led {
            width: 10px;
            height: 10px;
            border-radius: 9999px;
            background: #4b5563;
            box-shadow: 0 0 0 rgba(45,212,191,0);
            transition: background 0.1s ease, box-shadow 0.1s ease;
        }
        .metronome-led-active {
            background: #2dd4bf;
            box-shadow: 0 0 10px rgba(45,212,191,0.9);
        }

        @keyframes spin { 0%{transform:rotate(0deg)}100%{transform:rotate(360deg)} }
    </style>
</head>
<body class="h-screen flex flex-col text-gray-300">

<header class="h-14 bg-[#18181b] border-b border-[#27272a] flex items-center px-4 justify-between shrink-0 z-20">
    <div class="flex items-center gap-6">
        <div class="flex items-center gap-2">
            <div class="w-6 h-6 bg-gradient-to-br from-teal-400 to-blue-500 rounded-md"></div>
            <h1 class="font-bold text-white tracking-tight">PIANO<span class="text-teal-400">ROLL</span></h1>
        </div>
        <div class="h-6 w-px bg-[#333]"></div>
        <div class="flex items-center gap-2">
            <button id="btn-rewind" class="p-2 hover:text-white text-gray-400" title="Rewind (Home)">
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg>
            </button>
            <button id="btn-play" class="w-10 h-10 bg-[#27272a] hover:bg-[#3f3f46] rounded-full flex items-center justify-center text-white border border-[#3f3f46] shadow-lg" title="Play/Pause (Space)">
                <svg id="icon-play" class="w-5 h-5 ml-0.5" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                <svg id="icon-pause" class="w-5 h-5 hidden" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            </button>
            <button id="btn-stop" class="p-2 hover:text-white text-gray-400" title="Stop">
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M6 6h12v12H6z"/></svg>
            </button>
        </div>
        <div class="bg-black/30 px-3 py-1 rounded text-teal-400 font-mono text-sm border border-[#333]" id="time-display">
            0:0:0
        </div>
    </div>

    <div class="flex items-center gap-4">
        <div class="flex items-center gap-2">
            <span class="text-xs font-bold text-gray-500">BPM</span>
            <input type="number" id="bpm-input" value="120" min="30" max="300"
                   class="w-14 bg-[#27272a] border border-[#3f3f46] rounded px-2 py-0.5 text-sm text-center focus:outline-none focus:border-teal-500">
        </div>

        <button id="btn-metronome" class="flex items-center gap-2 text-xs text-gray-400 hover:text-teal-400 font-bold">
            <span id="metronome-led" class="metronome-led"></span>
            METRO
        </button>

        <div class="h-6 w-px bg-[#333]"></div>

        <div class="flex gap-2">
            <button id="tool-select" class="tool-btn active bg-teal-500/20 text-teal-400 border border-teal-500/50 px-3 py-1 rounded text-xs font-bold">SELECT</button>
            <button id="tool-pencil" class="tool-btn hover:bg-[#27272a] text-gray-400 border border-transparent hover:border-[#3f3f46] px-3 py-1 rounded text-xs font-bold">PENCIL</button>
            <button id="tool-eraser" class="tool-btn hover:bg-[#27272a] text-gray-400 border border-transparent hover:border-[#3f3f46] px-3 py-1 rounded text-xs font-bold">ERASER</button>
        </div>

        <div class="h-6 w-px bg-[#333]"></div>

        <button id="btn-clear" class="text-xs text-red-400 hover:text-red-300 font-bold px-2">CLEAR</button>
        <div class="flex gap-2">
            <button id="btn-import-json" class="bg-[#1f2937] hover:bg-[#27272a] text-white px-3 py-1.5 rounded text-xs font-bold border border-[#3f3f46]">IMPORT JSON</button>
            <button id="btn-export" class="bg-[#27272a] hover:bg-[#3f3f46] text-white px-3 py-1.5 rounded text-xs font-bold border border-[#3f3f46]">EXPORT JSON</button>
            <button id="btn-import-midi" class="bg-[#1f2937] hover:bg-[#27272a] text-white px-3 py-1.5 rounded text-xs font-bold border border-[#3f3f46]">IMPORT MIDI</button>
            <button id="btn-export-midi" class="bg-[#27272a] hover:bg-[#3f3f46] text-white px-3 py-1.5 rounded text-xs font-bold border border-[#3f3f46]">EXPORT MIDI</button>
        </div>
        <button id="btn-render" class="bg-gradient-to-r from-teal-600 to-teal-500 hover:from-teal-500 hover:to-teal-400 text-white px-3 py-1.5 rounded text-xs font-bold shadow-lg">RENDER WAV</button>
    </div>
</header>

<input id="import-json-input" type="file" accept="application/json,.json" class="hidden">
<input id="import-midi-input" type="file" accept=".mid,.midi,audio/midi" class="hidden">

<div class="flex-1 flex overflow-hidden bg-[#121212]" id="workspace">
    <div class="w-20 bg-[#1e1e1e] border-r border-[#333] flex flex-col shrink-0 relative overflow-hidden">
        <div class="h-8 border-b border-[#333] bg-[#222] shrink-0"></div>
        <div id="keys-viewport">
            <div id="keys-list"></div>
        </div>
    </div>

    <div class="flex-1 flex flex-col relative overflow-hidden" id="grid-wrapper">
        <div class="h-8 bg-[#18181b] border-b border-[#333] relative overflow-hidden" id="ruler">
            <canvas id="ruler-canvas" class="absolute top-0 left-0"></canvas>
        </div>

        <div class="flex-1 relative bg-[#121212]" id="grid-area">
            <div id="scroll-container" class="absolute inset-0 overflow-auto">
                <div id="piano-roll-content" class="relative"></div>
            </div>
            <canvas id="grid-canvas" class="absolute inset-0 z-0 pointer-events-none"></canvas>
            <canvas id="notes-canvas" class="absolute inset-0 z-10 pointer-events-none"></canvas>
            <div id="interaction-layer" class="absolute inset-0 z-20">
                <div id="selection-rect" class="selection-rect"></div>
            </div>
            <div id="playhead" class="absolute top-0 bottom-0 w-0.5 bg-teal-400 z-30 pointer-events-none shadow-[0_0_10px_rgba(45,212,191,0.8)]">
                <div class="w-3 h-3 -ml-1.5 bg-teal-400 rounded-full absolute -top-1.5"></div>
            </div>
        </div>

        <div id="velocity-lane" class="h-28 shrink-0">
            <div id="velocity-resize-handle"></div>
            <canvas id="velocity-canvas"></canvas>
        </div>
    </div>

    <div id="auto-panel" class="w-72 bg-[#020617] border-l border-[#27272a] flex flex-col shrink-0 text-xs p-3 gap-3">
        <div class="flex items-center justify-between mb-1">
            <span class="text-[10px] tracking-wide text-gray-400 font-semibold uppercase">Auto Compose</span>
        </div>
        <div class="space-y-3">
            <div>
                <label class="block text-[11px] text-gray-400 mb-1">Key</label>
                <div class="flex gap-1">
                    <select id="auto-key-root" class="flex-1 bg-[#030712] border border-[#27272a] rounded px-1 py-0.5">
                        <option selected>C</option>
                        <option>C#</option>
                        <option>D</option>
                        <option>D#</option>
                        <option>E</option>
                        <option>F</option>
                        <option>F#</option>
                        <option>G</option>
                        <option>G#</option>
                        <option>A</option>
                        <option>A#</option>
                        <option>B</option>
                    </select>
                    <select id="auto-key-mode" class="flex-1 bg-[#030712] border border-[#27272a] rounded px-1 py-0.5">
                        <option value="major" selected>Major</option>
                        <option value="minor">Minor</option>
                    </select>
                </div>
            </div>

            <div>
                <label class="block text-[11px] text-gray-400 mb-1">Verse Chords</label>
                <input id="auto-verse-chords" type="text" value="C | G | Am | F"
                       class="w-full bg-[#030712] border border-[#27272a] rounded px-1 py-0.5 text-[11px]">
                <p class="text-[10px] text-gray-500 mt-1">
                    Default: C | G | Am | F (I | V | vi | IV)
                </p>
            </div>

            <div>
                <label class="block text-[11px] text-gray-400 mb-1">Chorus Chords</label>
                <input id="auto-chorus-chords" type="text" value="C | Em | F | G"
                       class="w-full bg-[#030712] border border-[#27272a] rounded px-1 py-0.5 text-[11px]">
                <p class="text-[10px] text-gray-500 mt-1">
                    Default: C | Em | F | G (I | iii | IV | V)
                </p>
            </div>

            <div class="flex gap-2">
                <div class="flex-1">
                    <label class="block text-[11px] text-gray-400 mb-1">Hook Bars (motif)</label>
                    <input id="auto-hook-bars" type="number" min="1" max="8" value="4"
                           class="w-full bg-[#030712] border border-[#27272a] rounded px-1 py-0.5 text-[11px]">
                </div>
                <div class="flex-1">
                    <label class="block text-[11px] text-gray-400 mb-1">Total Bars</label>
                    <input id="auto-total-bars" type="number" min="8" max="180" value="90"
                           class="w-full bg-[#030712] border border-[#27272a] rounded px-1 py-0.5 text-[11px]">
                </div>
            </div>

            <div class="flex gap-2">
                <div class="flex-1">
                    <label class="block text-[11px] text-gray-400 mb-1">Density (Hooks)</label>
                    <select id="auto-density" class="w-full bg-[#030712] border border-[#27272a] rounded px-1 py-0.5">
                        <option value="sparse">Sparse</option>
                        <option value="medium">Medium</option>
                        <option value="dense" selected>Dense</option>
                    </select>
                </div>
                <div class="flex-1">
                    <label class="block text-[11px] text-gray-400 mb-1">Range (Chorus)</label>
                    <select id="auto-range" class="w-full bg-[#030712] border border-[#27272a] rounded px-1 py-0.5">
                        <option value="low">Low</option>
                        <option value="mid" selected>Mid</option>
                        <option value="high">High</option>
                    </select>
                </div>
            </div>

            <div>
                <label class="block text-[11px] text-gray-400 mb-1">Arrangement</label>
                <div class="space-y-1 text-[11px] text-gray-300">
                    <label class="flex items-center gap-1">
                        <input id="auto-gen-bass" type="checkbox" class="bg-transparent" checked>
                        <span>Bass line</span>
                    </label>
                    <label class="flex items-center gap-1">
                        <input id="auto-gen-chords" type="checkbox" class="bg-transparent" checked>
                        <span>Pad / Arp chords</span>
                    </label>
                    <p class="text-[10px] text-gray-500">
                        Auto composer will also create hook, bass, and pad parts when enabled above.
                    </p>
                </div>
            </div>

            <div class="flex gap-2">
                <button id="btn-auto-random"
                        class="flex-1 py-1.5 bg-[#111827] hover:bg-[#1f2937] text-gray-200 font-bold rounded text-[11px] border border-[#27272a]">
                    Randomize Settings
                </button>
                <button id="btn-auto-generate"
                        class="flex-1 py-1.5 bg-teal-600 hover:bg-teal-500 text-white font-bold rounded text-[11px]">
                    Generate Song
                </button>
            </div>
        </div>
    </div>
</div>

<div id="loading-overlay" class="fixed inset-0 z-50 bg-[#09090b] flex flex-col items-center justify-center gap-4">
    <h2 class="text-2xl font-bold text-white tracking-wider">PIANO<span class="text-teal-500">ROLL</span> STUDIO</h2>
    <div class="flex items-center gap-3 text-gray-400">
        <div class="loader"></div>
        <span id="loading-text">Loading High-Res Piano Samples...</span>
    </div>
</div>

<div id="start-overlay" class="fixed inset-0 z-50 bg-black/80 backdrop-blur-md flex items-center justify-center hidden">
    <div class="bg-[#18181b] border border-[#333] p-8 rounded-xl shadow-2xl max-w-lg text-center space-y-6">
        <div class="w-16 h-16 bg-teal-500/10 rounded-full flex items-center justify-center mx-auto text-teal-400">
            <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
        </div>
        <div>
            <h2 class="text-3xl font-bold text-white mb-2">Ready to Compose?</h2>
            <p class="text-gray-400">Click below to initialize the audio engine and start creating.</p>
        </div>
        <button id="init-btn" class="w-full py-3 bg-teal-600 hover:bg-teal-500 text-white font-bold rounded-lg">ENTER STUDIO</button>
        <p class="text-xs text-gray-500">Tip: Space = Play / Stop, Delete = remove notes.</p>
    </div>
</div>

<script>
    const CONFIG = {
        rowHeight: 24,
        beatWidth: 80,
        octaves: 8,
        startOctave: 1,
        totalMeasures: 90,
        zoom: {
            minBeatWidth: 20,
            maxBeatWidth: 200,
            minRowHeight: 12,
            maxRowHeight: 40
        },
        colors: {
            bg: '#121212',
            gridMain: '#2a2a2a',
            gridSub: '#1e1e1e',
            blackKeyRow: '#161616',
            note: '#2dd4bf',
            noteSelected: '#f0fdf4',
            noteBorder: '#115e59'
        }
    };

    const ORNAMENT_NOTE_DURATION = 0.125; // Default 1/8-beat duration for generated ornaments.
    const MELODY_STYLES = ['smooth', 'hooky', 'leapy'];

    const totalKeys = CONFIG.octaves * 12;
    let totalWidth = CONFIG.totalMeasures * 4 * CONFIG.beatWidth;
    let totalHeight = totalKeys * CONFIG.rowHeight;

    const STATE = {
        notes: [],
        isPlaying: false,
        bpm: 120,
        currentTool: 'select',
        snapToGrid: 0.25,
        selectedNotes: new Set(),
        isDragging: false,
        isSelecting: false,
        dragAction: null,
        dragStart: { x: 0, y: 0, vx: 0, vy: 0, screenX: 0, screenY: 0 },
        hoverNote: null,
        dragStartNotes: {},
        selectionStartState: null,
        pianoLoaded: false,
        hasPendingHistorySnapshot: false,
        lastPointerBeat: null,
        lastPointerRow: null,
        currentBeat: 0,
        clipboard: null,
        metronomeEnabled: false,
        velocityLaneHeight: 112
    };

    const HISTORY = {
        undoStack: [],
        redoStack: [],
        maxLength: 200,
        isRestoring: false
    };

    const els = {
        scrollContainer: document.getElementById('scroll-container'),
        gridArea: document.getElementById('grid-area'),
        selectionRect: document.getElementById('selection-rect'),
        content: document.getElementById('piano-roll-content'),
        keysList: document.getElementById('keys-list'),
        gridCanvas: document.getElementById('grid-canvas'),
        notesCanvas: document.getElementById('notes-canvas'),
        rulerCanvas: document.getElementById('ruler-canvas'),
        interaction: document.getElementById('interaction-layer'),
        playhead: document.getElementById('playhead'),
        timeDisplay: document.getElementById('time-display'),
        bpmInput: document.getElementById('bpm-input'),
        btnPlay: document.getElementById('btn-play'),
        btnStop: document.getElementById('btn-stop'),
        btnRewind: document.getElementById('btn-rewind'),
        btnExport: document.getElementById('btn-export'),
        btnExportMidi: document.getElementById('btn-export-midi'),
        btnImportJson: document.getElementById('btn-import-json'),
        btnImportMidi: document.getElementById('btn-import-midi'),
        importJsonInput: document.getElementById('import-json-input'),
        importMidiInput: document.getElementById('import-midi-input'),
        btnClear: document.getElementById('btn-clear'),
        iconPlay: document.getElementById('icon-play'),
        iconPause: document.getElementById('icon-pause'),
        loading: document.getElementById('loading-overlay'),
        startOverlay: document.getElementById('start-overlay'),
        velocityLane: document.getElementById('velocity-lane'),
        velocityCanvas: document.getElementById('velocity-canvas'),
        velocityResize: document.getElementById('velocity-resize-handle'),
        btnMetronome: document.getElementById('btn-metronome'),
        metronomeLed: document.getElementById('metronome-led')
    };

    const autoEls = {
        keyRoot: document.getElementById('auto-key-root'),
        keyMode: document.getElementById('auto-key-mode'),
        verseChords: document.getElementById('auto-verse-chords'),
        chorusChords: document.getElementById('auto-chorus-chords'),
        hookBars: document.getElementById('auto-hook-bars'),
        totalBars: document.getElementById('auto-total-bars'),
        density: document.getElementById('auto-density'),
        range: document.getElementById('auto-range'),
        genBass: document.getElementById('auto-gen-bass'),
        genChords: document.getElementById('auto-gen-chords'),
        generateBtn: document.getElementById('btn-auto-generate'),
        randomBtn: document.getElementById('btn-auto-random')
    };

    const NOTE_TO_SEMITONE = {
        'C': 0, 'C#': 1, 'DB': 1, 'D': 2, 'D#': 3, 'EB': 3,
        'E': 4, 'F': 5, 'F#': 6, 'GB': 6, 'G': 7, 'G#': 8, 'AB': 8,
        'A': 9, 'A#': 10, 'BB': 10, 'B': 11
    };
    const PC_TO_NOTE = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

    const DEFAULT_VERSE_PROGRESS = "C | G | Am | F";
    const DEFAULT_CHORUS_PROGRESS = "C | Em | F | G";

    let pianoSampler;
    let metronomeSynth;
    let metronomeId = null;
    let mainPart = null;
    let toneResumePromise = null;

    function ensureToneContextRunning() {
        if (Tone.context.state === 'running') {
            return Promise.resolve();
        }
        if (toneResumePromise) {
            return toneResumePromise;
        }
        toneResumePromise = Tone.start()
            .catch(err => {
                console.warn('Tone.start() failed:', err);
                throw err;
            })
            .finally(() => {
                toneResumePromise = null;
            });
        return toneResumePromise;
    }

    function setupAudioUnlockOnGesture() {
        const gestureEvents = ['pointerdown', 'touchstart', 'keydown'];
        const unlock = () => {
            ensureToneContextRunning();
            gestureEvents.forEach(evt => window.removeEventListener(evt, unlock));
        };
        gestureEvents.forEach(evt => window.addEventListener(evt, unlock));
    }

    setupAudioUnlockOnGesture();

    async function initAudio() {
        await ensureToneContextRunning();
        Tone.Transport.bpm.value = STATE.bpm;

        pianoSampler = new Tone.Sampler({
            urls: {
                A0: "A0.mp3", C1: "C1.mp3", "D#1": "Ds1.mp3", "F#1": "Fs1.mp3", A1: "A1.mp3",
                C2: "C2.mp3", "D#2": "Ds2.mp3", "F#2": "Fs2.mp3", A2: "A2.mp3",
                C3: "C3.mp3", "D#3": "Ds3.mp3", "F#3": "Fs3.mp3", A3: "A3.mp3",
                C4: "C4.mp3", "D#4": "Ds4.mp3", "F#4": "Fs4.mp3", A4: "A4.mp3",
                C5: "C5.mp3", "D#5": "Ds5.mp3", "F#5": "Fs5.mp3", A5: "A5.mp3",
                C6: "C6.mp3", "D#6": "Ds6.mp3", "F#6": "Fs6.mp3", A6: "A6.mp3",
                C7: "C7.mp3", "D#7": "Ds7.mp3", "F#7": "Fs7.mp3", A7: "A7.mp3",
                C8: "C8.mp3"
            },
            release: 1,
            curve: 'exponential',
            volume: -5,
            baseUrl: "https://tonejs.github.io/audio/salamander/"
        }).toDestination();

        metronomeSynth = new Tone.MembraneSynth({
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.0, release: 0.05 }
        }).toDestination();

        await Tone.loaded();
        STATE.pianoLoaded = true;
    }

    function recalcWorldDimensions() {
        totalWidth = CONFIG.totalMeasures * 4 * CONFIG.beatWidth;
        totalHeight = totalKeys * CONFIG.rowHeight;
        els.content.style.width = `${totalWidth}px`;
        els.content.style.height = `${totalHeight}px`;
        els.keysList.style.height = `${totalHeight}px`;
    }

    function getMidiFromRow(row) {
        return ((CONFIG.startOctave + CONFIG.octaves) * 12) - row;
    }
    function getRowFromMidi(midi) {
        const row = ((CONFIG.startOctave + CONFIG.octaves) * 12) - midi;
        return Math.max(0, Math.min(totalKeys - 1, row));
    }
    function getNoteName(midi) {
        return Tone.Frequency(midi, "midi").toNote();
    }

    function initUI() {
        recalcWorldDimensions();
        resizeOverlayCanvases();
        generateKeys();
        drawGrid();
        drawNotes();
        drawVelocityLane();
        renderRuler();

        const c4Midi = 60;
        const topNoteMidi = (CONFIG.startOctave + CONFIG.octaves) * 12;
        const c4RowIndex = topNoteMidi - c4Midi;
        const scrollY = c4RowIndex * CONFIG.rowHeight;
        els.scrollContainer.scrollTop = scrollY - els.scrollContainer.offsetHeight / 2;

        els.loading.classList.add('hidden');
        captureHistorySnapshot();
    }

    function resizeOverlayCanvases() {
        const rect = els.gridArea.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;
        const dpr = window.devicePixelRatio || 1;

        [els.gridCanvas, els.notesCanvas].forEach(c => {
            c.width = w * dpr;
            c.height = h * dpr;
            c.style.width = w + 'px';
            c.style.height = h + 'px';
        });

        els.interaction.style.width = w + 'px';
        els.interaction.style.height = h + 'px';

        const vRect = els.velocityLane.getBoundingClientRect();
        els.velocityCanvas.width = vRect.width * dpr;
        els.velocityCanvas.height = (vRect.height - 4) * dpr;
        els.velocityCanvas.style.width = vRect.width + 'px';
        els.velocityCanvas.style.height = (vRect.height - 4) + 'px';

        renderAll();
    }

    function generateKeys() {
        els.keysList.innerHTML = '';
        for (let i = 0; i < totalKeys; i++) {
            const midi = getMidiFromRow(i);
            const noteName = getNoteName(midi);
            const isBlack = noteName.includes('#');

            const row = document.createElement('div');
            row.className = 'piano-row';
            row.style.height = `${CONFIG.rowHeight}px`;
            row.style.top = `${i * CONFIG.rowHeight}px`;
            row.dataset.midi = midi;

            const base = document.createElement('div');
            base.className = 'key-base';
            row.appendChild(base);

            if (isBlack) {
                const bk = document.createElement('div');
                bk.className = 'black-key';
                row.appendChild(bk);

                const partialDiv = document.createElement('div');
                partialDiv.className = 'key-divider-partial';
                row.appendChild(partialDiv);
            }

            if (!isBlack) {
                if (i < totalKeys - 1) {
                    const nextMidi = getMidiFromRow(i + 1);
                    const nextName = getNoteName(nextMidi);
                    const nextIsBlack = nextName.includes('#');
                    if (!nextIsBlack) {
                        const div = document.createElement('div');
                        div.className = 'key-divider';
                        row.appendChild(div);
                    }
                } else {
                    const div = document.createElement('div');
                    div.className = 'key-divider';
                    row.appendChild(div);
                }

                if (noteName.startsWith('C') && !noteName.includes('#')) {
                    const lbl = document.createElement('div');
                    lbl.className = 'key-label';
                    lbl.innerText = noteName;
                    row.appendChild(lbl);
                }
            }

            row.onmousedown = () => playNotePreview(midi);
            els.keysList.appendChild(row);
        }
    }

    function playNotePreview(midi, duration = '8n') {
        if (STATE.pianoLoaded && pianoSampler) {
            pianoSampler.triggerAttackRelease(getNoteName(midi), duration);
        }
    }

    function getViewportInfo() {
        const scrollLeft = els.scrollContainer.scrollLeft;
        const scrollTop = els.scrollContainer.scrollTop;
        const w = els.gridArea.clientWidth;
        const h = els.gridArea.clientHeight;
        return { scrollLeft, scrollTop, w, h };
    }

    function drawGrid() {
        const ctx = els.gridCanvas.getContext('2d');
        const { scrollLeft, scrollTop, w, h } = getViewportInfo();
        const dpr = window.devicePixelRatio || 1;
        els.gridCanvas.width = w * dpr;
        els.gridCanvas.height = h * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        ctx.fillStyle = CONFIG.colors.bg;
        ctx.fillRect(0, 0, w, h);

        const paddingRows = 2;
        const paddingBeats = 4;
        const firstRow = Math.max(0, Math.floor(scrollTop / CONFIG.rowHeight) - paddingRows);
        const lastRow = Math.min(totalKeys - 1, Math.ceil((scrollTop + h) / CONFIG.rowHeight) + paddingRows);

        const totalBeats = CONFIG.totalMeasures * 4;
        const firstBeat = Math.max(0, Math.floor(scrollLeft / CONFIG.beatWidth) - paddingBeats);
        const lastBeat = Math.min(totalBeats, Math.ceil((scrollLeft + w) / CONFIG.beatWidth) + paddingBeats);

        for (let row = firstRow; row <= lastRow; row++) {
            const midi = getMidiFromRow(row);
            const isBlack = getNoteName(midi).includes('#');
            const yWorld = row * CONFIG.rowHeight;
            const y = yWorld - scrollTop;

            if (isBlack) {
                ctx.fillStyle = CONFIG.colors.blackKeyRow;
                ctx.fillRect(0, y, w, CONFIG.rowHeight);
            }

            ctx.strokeStyle = CONFIG.colors.gridSub;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
            ctx.stroke();
        }

        for (let beat = firstBeat; beat <= lastBeat; beat++) {
            const xWorld = beat * CONFIG.beatWidth;
            const x = xWorld - scrollLeft;
            const isMeasure = beat % 4 === 0;
            ctx.strokeStyle = isMeasure ? CONFIG.colors.gridMain : CONFIG.colors.gridSub;
            ctx.lineWidth = isMeasure ? 1 : 0.5;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, h);
            ctx.stroke();
        }
    }

    function hexToRgba(hex, alpha) {
        const c = hex.replace('#', '');
        const num = parseInt(c, 16);
        const r = (num >> 16) & 255;
        const g = (num >> 8) & 255;
        const b = num & 255;
        return `rgba(${r},${g},${b},${alpha})`;
    }

    function drawNotes() {
        const ctx = els.notesCanvas.getContext('2d');
        const { scrollLeft, scrollTop, w, h } = getViewportInfo();
        const dpr = window.devicePixelRatio || 1;
        els.notesCanvas.width = w * dpr;
        els.notesCanvas.height = h * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, w, h);

        const paddingX = CONFIG.beatWidth * 2;
        const paddingY = CONFIG.rowHeight * 2;
        const left = scrollLeft - paddingX;
        const right = scrollLeft + w + paddingX;
        const top = scrollTop - paddingY;
        const bottom = scrollTop + h + paddingY;

        STATE.notes.forEach(note => {
            const xWorld = note.start * CONFIG.beatWidth;
            const yWorld = note.row * CONFIG.rowHeight;
            const wWorld = note.duration * CONFIG.beatWidth;
            const hWorld = CONFIG.rowHeight;

            if (xWorld + wWorld < left || xWorld > right || yWorld + hWorld < top || yWorld > bottom) return;

            const x = xWorld - scrollLeft;
            const y = yWorld - scrollTop;
            const isSelected = STATE.selectedNotes.has(note.id);

            if (isSelected) {
                ctx.shadowColor = CONFIG.colors.note;
                ctx.shadowBlur = 10;
            } else {
                ctx.shadowBlur = 0;
            }

            const base = isSelected ? CONFIG.colors.noteSelected : CONFIG.colors.note;
            const alpha = 0.5 + (note.velocity || 0.8) * 0.5;
            ctx.fillStyle = hexToRgba(base, alpha);
            ctx.strokeStyle = CONFIG.colors.noteBorder;
            ctx.lineWidth = 1;

            ctx.fillRect(x + 1, y + 1, wWorld - 2, hWorld - 2);
            ctx.strokeRect(x + 1, y + 1, wWorld - 2, hWorld - 2);

            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.fillRect(x + wWorld - 5, y + 1, 4, hWorld - 2);
        });
    }

    function drawVelocityLane() {
        const ctx = els.velocityCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const vRect = els.velocityLane.getBoundingClientRect();
        const height = vRect.height - 4;
        const width = vRect.width;
        els.velocityCanvas.width = width * dpr;
        els.velocityCanvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);

        ctx.fillStyle = '#111827';
        ctx.fillRect(0, 0, width, height);
        ctx.strokeStyle = '#1f2933';
        ctx.beginPath();
        ctx.moveTo(0, height * 0.5);
        ctx.lineTo(width, height * 0.5);
        ctx.stroke();

        const { scrollLeft } = getViewportInfo();
        const paddingX = CONFIG.beatWidth * 2;
        const left = scrollLeft - paddingX;
        const right = scrollLeft + width + paddingX;

        STATE.notes.forEach(note => {
            const xWorld = note.start * CONFIG.beatWidth;
            const wWorld = note.duration * CONFIG.beatWidth;
            const centerWorld = xWorld + wWorld / 2;
            if (centerWorld < left || centerWorld > right) return;

            const x = centerWorld - scrollLeft;
            const barW = Math.max(3, Math.min(12, wWorld * 0.3));
            const velocity = note.velocity != null ? note.velocity : 0.8;
            const barH = velocity * (height - 8);
            const y = height - barH;

            const isSelected = STATE.selectedNotes.has(note.id);
            ctx.fillStyle = isSelected ? '#fbbf24' : '#22c55e';
            ctx.fillRect(x - barW / 2, y, barW, barH);
        });
    }

    function velocityFromY(y, height) {
        const v = 1 - (y / height);
        return Math.min(1, Math.max(0, v));
    }

    let velocityEditState = {
        active: false,
        noteIds: []
    };

    els.velocityCanvas.addEventListener('mousedown', (e) => {
        const rect = els.velocityCanvas.getBoundingClientRect();
        const xView = e.clientX - rect.left;
        const yView = e.clientY - rect.top;
        const { scrollLeft } = getViewportInfo();
        const worldX = xView + scrollLeft;
        const worldBeat = worldX / CONFIG.beatWidth;

        let targetIds = [];

        if (STATE.selectedNotes.size > 0) {
            STATE.notes.forEach(n => {
                if (!STATE.selectedNotes.has(n.id)) return;
                if (worldBeat >= n.start && worldBeat <= n.start + n.duration) {
                    targetIds.push(n.id);
                }
            });
        }

        if (targetIds.length === 0) {
            const targetNote = findNoteForVelocityEdit(worldBeat);
            if (!targetNote) return;
            targetIds = [targetNote.id];
        }

        velocityEditState.active = true;
        velocityEditState.noteIds = targetIds;

        const height = rect.height;
        const v = velocityFromY(yView, height);
        targetIds.forEach(id => {
            const note = STATE.notes.find(n => n.id === id);
            if (note) note.velocity = v;
        });

        STATE.hasPendingHistorySnapshot = true;
        drawNotes();
        drawVelocityLane();
        syncTransport();
    });

    function findNoteForVelocityEdit(worldBeat) {
        const { scrollLeft } = getViewportInfo();
        const width = els.velocityCanvas.clientWidth;
        const left = scrollLeft;
        const right = scrollLeft + width;

        const hits = STATE.notes
            .map(n => {
                const xWorld = n.start * CONFIG.beatWidth;
                const wWorld = n.duration * CONFIG.beatWidth;
                const centerWorld = xWorld + wWorld / 2;
                return { note: n, centerWorld };
            })
            .filter(({ centerWorld }) => centerWorld >= left && centerWorld <= right)
            .map(({ note, centerWorld }) => ({
                note,
                dist: Math.abs(centerWorld / CONFIG.beatWidth - worldBeat)
            }))
            .sort((a, b) => a.dist - b.dist);

        return hits.length > 0 ? hits[0].note : null;
    }

    function renderRuler() {
        const ctx = els.rulerCanvas.getContext('2d');
        const { scrollLeft, w } = getViewportInfo();
        els.rulerCanvas.width = w;
        els.rulerCanvas.height = 32;

        ctx.fillStyle = '#18181b';
        ctx.fillRect(0, 0, w, 32);
        ctx.fillStyle = '#888';
        ctx.font = '10px sans-serif';

        const startBeat = Math.floor(scrollLeft / CONFIG.beatWidth);
        const endBeat = startBeat + Math.ceil(w / CONFIG.beatWidth) + 1;

        for (let i = startBeat; i < endBeat; i++) {
            const x = (i * CONFIG.beatWidth) - scrollLeft;
            if (x < -50) continue;
            if (i % 4 === 0) {
                ctx.fillRect(x, 15, 1, 17);
                ctx.fillText((i / 4) + 1, x + 4, 28);
            } else {
                ctx.fillRect(x, 25, 1, 7);
            }
        }
    }

    function getGridPos(e) {
        const rect = els.interaction.getBoundingClientRect();
        const vx = e.clientX - rect.left;
        const vy = e.clientY - rect.top;
        const { scrollLeft, scrollTop } = getViewportInfo();
        const x = vx + scrollLeft;
        const y = vy + scrollTop;
        return { x, y, vx, vy };
    }

    function getNoteAtPos(xWorld, yWorld) {
        for (let i = STATE.notes.length - 1; i >= 0; i--) {
            const n = STATE.notes[i];
            const nx = n.start * CONFIG.beatWidth;
            const ny = n.row * CONFIG.rowHeight;
            const nw = n.duration * CONFIG.beatWidth;
            const nh = CONFIG.rowHeight;
            if (xWorld >= nx && xWorld <= nx + nw && yWorld >= ny && yWorld <= ny + nh) {
                const isResize = xWorld >= nx + nw - 10;
                return { note: n, isResize };
            }
        }
        return null;
    }

    els.interaction.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        const { x, y, vx, vy } = getGridPos(e);
        STATE.dragStart = { x, y, vx, vy, screenX: e.clientX, screenY: e.clientY };
        STATE.lastPointerBeat = x / CONFIG.beatWidth;
        STATE.lastPointerRow = y / CONFIG.rowHeight;

        const hit = getNoteAtPos(x, y);

        if (STATE.currentTool === 'eraser') {
            if (hit) {
                deleteNote(hit.note.id);
                STATE.hasPendingHistorySnapshot = true;
                captureHistorySnapshot();
            }
            return;
        }

        if (hit) {
            if (STATE.currentTool === 'select' || STATE.currentTool === 'pencil') {
                if (e.shiftKey) {
                    STATE.selectedNotes.add(hit.note.id);
                } else {
                    if (!STATE.selectedNotes.has(hit.note.id)) {
                        STATE.selectedNotes.clear();
                        STATE.selectedNotes.add(hit.note.id);
                    }
                }
                drawNotes();

                STATE.isDragging = true;
                STATE.hoverNote = hit.note;
                STATE.dragStartNotes = {};
                STATE.selectedNotes.forEach(id => {
                    const n = STATE.notes.find(note => note.id === id);
                    if (n) STATE.dragStartNotes[id] = { ...n };
                });
                STATE.dragAction = hit.isResize ? 'resize-end' : 'move';

                if (!hit.isResize) playNotePreview(getMidiFromRow(hit.note.row));
            }
        } else {
            if (STATE.currentTool === 'pencil') {
                const startBeat = snapBeat(x / CONFIG.beatWidth);
                const row = Math.floor(y / CONFIG.rowHeight);
                const newNote = {
                    id: generateNoteId(),
                    row,
                    start: startBeat,
                    duration: 1,
                    velocity: 0.8
                };
                STATE.notes.push(newNote);
                STATE.selectedNotes.clear();
                STATE.selectedNotes.add(newNote.id);
                STATE.hoverNote = newNote;
                STATE.dragStartNotes = { [newNote.id]: { ...newNote } };
                STATE.isDragging = true;
                STATE.dragAction = 'resize-end';
                STATE.hasPendingHistorySnapshot = true;
                playNotePreview(getMidiFromRow(row));
                drawNotes();
                drawVelocityLane();
                syncTransport();
            } else if (STATE.currentTool === 'select') {
                STATE.isSelecting = true;
                if (!e.shiftKey) STATE.selectedNotes.clear();
                STATE.selectionStartState = new Set(STATE.selectedNotes);
                els.selectionRect.style.display = 'block';
                els.selectionRect.style.left = vx + 'px';
                els.selectionRect.style.top = vy + 'px';
                els.selectionRect.style.width = '0px';
                els.selectionRect.style.height = '0px';
            }
        }
    });

    function handleGridMouseMove(e) {
        const { x, y, vx, vy } = getGridPos(e);
        STATE.lastPointerBeat = x / CONFIG.beatWidth;
        STATE.lastPointerRow = y / CONFIG.rowHeight;

        if (STATE.isSelecting) {
            const startVX = Math.min(vx, STATE.dragStart.vx);
            const startVY = Math.min(vy, STATE.dragStart.vy);
            const width = Math.abs(vx - STATE.dragStart.vx);
            const height = Math.abs(vy - STATE.dragStart.vy);
            els.selectionRect.style.left = startVX + 'px';
            els.selectionRect.style.top = startVY + 'px';
            els.selectionRect.style.width = width + 'px';
            els.selectionRect.style.height = height + 'px';

            const { scrollLeft, scrollTop } = getViewportInfo();
            const leftWorld = startVX + scrollLeft;
            const rightWorld = leftWorld + width;
            const topWorld = startVY + scrollTop;
            const bottomWorld = topWorld + height;
            const newSelection = new Set(STATE.selectionStartState);

            STATE.notes.forEach(n => {
                const nx = n.start * CONFIG.beatWidth;
                const ny = n.row * CONFIG.rowHeight;
                const nw = n.duration * CONFIG.beatWidth;
                const nh = CONFIG.rowHeight;
                if (leftWorld < nx + nw && rightWorld > nx && topWorld < ny + nh && bottomWorld > ny) {
                    newSelection.add(n.id);
                }
            });

            STATE.selectedNotes = newSelection;
            drawNotes();
            return;
        }

        if (!STATE.isDragging) {
            const hit = getNoteAtPos(x, y);
            if (hit) {
                els.interaction.style.cursor = hit.isResize ? 'ew-resize' : 'move';
            } else {
                els.interaction.style.cursor = STATE.currentTool === 'pencil' ? 'crosshair' : 'default';
            }
            return;
        }

        const dx = e.clientX - STATE.dragStart.screenX;
        const dy = e.clientY - STATE.dragStart.screenY;

        if (STATE.dragAction === 'move') {
            const snapW = CONFIG.beatWidth * STATE.snapToGrid;
            const beatDelta = Math.round(dx / snapW) * STATE.snapToGrid;
            const rowDelta = Math.round(dy / CONFIG.rowHeight);

            STATE.selectedNotes.forEach(id => {
                const startState = STATE.dragStartNotes[id];
                if (!startState) return;
                const note = STATE.notes.find(n => n.id === id);
                if (!note) return;
                const newStart = Math.max(0, startState.start + beatDelta);
                const newRow = startState.row + rowDelta;
                if (newRow >= 0 && newRow < totalKeys) note.row = newRow;
                note.start = newStart;
            });
            STATE.hasPendingHistorySnapshot = true;
            drawNotes();
            drawVelocityLane();
        } else if (STATE.dragAction === 'resize-end') {
            const beatDelta = Math.round((dx / CONFIG.beatWidth) / STATE.snapToGrid) * STATE.snapToGrid;
            STATE.selectedNotes.forEach(id => {
                const startState = STATE.dragStartNotes[id];
                if (!startState) return;
                const note = STATE.notes.find(n => n.id === id);
                if (note) note.duration = Math.max(STATE.snapToGrid, startState.duration + beatDelta);
            });
            STATE.hasPendingHistorySnapshot = true;
            drawNotes();
            drawVelocityLane();
        }
    }

    function handleGridMouseUp() {
        if (STATE.isSelecting) {
            STATE.isSelecting = false;
            els.selectionRect.style.display = 'none';
        }
        if (STATE.isDragging) {
            STATE.isDragging = false;
            STATE.dragAction = null;
            STATE.hoverNote = null;
            STATE.dragStartNotes = {};
            syncTransport();
            if (STATE.hasPendingHistorySnapshot) {
                captureHistorySnapshot();
                STATE.hasPendingHistorySnapshot = false;
            }
        }
    }

    window.addEventListener('mousemove', (e) => {
        const rect = els.velocityCanvas.getBoundingClientRect();
        if (velocityEditState.active && rect.width > 0 && rect.height > 0) {
            const yView = e.clientY - rect.top;
            if (yView < 0 || yView > rect.height) return;
            const v = velocityFromY(yView, rect.height);
            velocityEditState.noteIds.forEach(id => {
                const note = STATE.notes.find(n => n.id === id);
                if (note) note.velocity = v;
            });
            STATE.hasPendingHistorySnapshot = true;
            drawNotes();
            drawVelocityLane();
            syncTransport();
            return;
        }
        handleGridMouseMove(e);
    });

    window.addEventListener('mouseup', () => {
        if (velocityEditState.active) {
            velocityEditState.active = false;
            velocityEditState.noteIds = [];
            if (STATE.hasPendingHistorySnapshot) {
                captureHistorySnapshot();
                STATE.hasPendingHistorySnapshot = false;
            }
        }
        handleGridMouseUp();
    });

    els.scrollContainer.addEventListener('scroll', () => {
        renderRuler();
        els.keysList.style.transform = `translateY(-${els.scrollContainer.scrollTop}px)`;
        drawGrid();
        drawNotes();
        drawVelocityLane();
    });

    function generateNoteId() {
        return 'n_' + Math.random().toString(36).slice(2) + Date.now().toString(36);
    }
    function snapBeat(beat) {
        const s = STATE.snapToGrid;
        return Math.round(beat / s) * s;
    }

    function deleteNote(id) {
        STATE.notes = STATE.notes.filter(n => n.id !== id);
        STATE.selectedNotes.delete(id);
        drawNotes();
        drawVelocityLane();
        syncTransport();
        STATE.hasPendingHistorySnapshot = true;
    }

    function clampRow(row) {
        if (Number.isNaN(row)) return 0;
        return Math.max(0, Math.min(totalKeys - 1, Math.round(row)));
    }

    function clampBpmValue(value) {
        const bpm = Number.isFinite(value) ? value : 120;
        return Math.max(30, Math.min(300, Math.round(bpm)));
    }

    function ensureGridFitsNotes(notes) {
        if (!Array.isArray(notes) || notes.length === 0) return;
        const lastBeat = notes.reduce((max, n) => Math.max(max, n.start + n.duration), 0);
        const currentBeats = CONFIG.totalMeasures * 4;
        if (lastBeat > currentBeats - 4) {
            CONFIG.totalMeasures = Math.max(CONFIG.totalMeasures, Math.ceil(lastBeat / 4) + 4);
            recalcWorldDimensions();
            resizeOverlayCanvases();
        }
    }

    function applyImportedProject(notes, bpm) {
        notes.sort((a, b) => a.start - b.start);
        ensureGridFitsNotes(notes);
        STATE.notes = notes;
        STATE.selectedNotes.clear();
        STATE.clipboard = null;
        STATE.bpm = clampBpmValue(bpm || STATE.bpm || 120);
        els.bpmInput.value = STATE.bpm;
        if (typeof Tone !== 'undefined' && Tone.Transport) {
            Tone.Transport.bpm.value = STATE.bpm;
        }
        drawNotes();
        drawVelocityLane();
        syncTransport();
        STATE.hasPendingHistorySnapshot = true;
        captureHistorySnapshot();
    }

    function getTransportTime(beats) {
        const bars = Math.floor(beats / 4);
        const quarters = Math.floor(beats % 4);
        const sixteenths = Math.round((beats % 1) * 4);
        return `${bars}:${quarters}:${sixteenths}`;
    }

    function syncTransport() {
        const wasPlaying = STATE.isPlaying;
        if (wasPlaying) Tone.Transport.pause();

        if (mainPart) {
            mainPart.dispose();
            mainPart = null;
        }
        Tone.Transport.cancel();

        const events = STATE.notes.map(n => ({
            time: getTransportTime(n.start),
            note: getNoteName(getMidiFromRow(n.row)),
            duration: getTransportTime(n.duration),
            velocity: n.velocity != null ? n.velocity : 0.8
        }));

        mainPart = new Tone.Part((time, value) => {
            if (STATE.pianoLoaded && pianoSampler) {
                pianoSampler.triggerAttackRelease(value.note, value.duration, time, value.velocity);
            }
        }, events);
        mainPart.start(0);

        let loopBars = CONFIG.totalMeasures;
        if (STATE.notes.length > 0) {
            const lastEnd = STATE.notes.reduce((max, n) => Math.max(max, n.start + n.duration), 0);
            loopBars = Math.max(1, Math.ceil(lastEnd / 4) + 1);
        }

        Tone.Transport.loop = true;
        Tone.Transport.loopStart = 0;
        Tone.Transport.loopEnd = `${loopBars}:0:0`;

        setupMetronomeSchedule();
        if (wasPlaying) Tone.Transport.start();
    }

    function updatePlayhead() {
        if (Tone.Transport.state !== 'started') return;
        const beat = Tone.Transport.ticks / Tone.Transport.PPQ;
        STATE.currentBeat = beat;
        const { scrollLeft, w } = getViewportInfo();
        const xView = beat * CONFIG.beatWidth - scrollLeft;
        els.playhead.style.transform = `translateX(${xView}px)`;
        const viewRight = scrollLeft + w;
        const viewLeft = scrollLeft;
        const worldX = beat * CONFIG.beatWidth;

        if (STATE.isPlaying) {
            if (worldX > viewRight - 50) {
                els.scrollContainer.scrollLeft = worldX - 50;
            } else if (worldX < viewLeft) {
                els.scrollContainer.scrollLeft = Math.max(0, worldX - 50);
            }
        }
        els.timeDisplay.innerText = Tone.Transport.position.split('.')[0];
    }

    function setupMetronomeSchedule() {
        if (metronomeId != null) {
            Tone.Transport.clear(metronomeId);
            metronomeId = null;
        }
        if (!STATE.metronomeEnabled || !metronomeSynth) return;

        metronomeId = Tone.Transport.scheduleRepeat((time) => {
            const pos = Tone.Transport.position.split(':');
            const quarter = parseInt(pos[1] || '0', 10);
            const sixteenth = parseInt(pos[2] || '0', 10);
            const isDownBeat = (quarter === 0 && sixteenth === 0);
            const freqNote = isDownBeat ? "C6" : "C5";
            metronomeSynth.triggerAttackRelease(freqNote, "16n", time);
            flashMetronomeLed(isDownBeat);
        }, "4n");
    }

    function flashMetronomeLed(isDownBeat) {
        els.metronomeLed.classList.add('metronome-led-active');
        setTimeout(() => {
            els.metronomeLed.classList.remove('metronome-led-active');
        }, isDownBeat ? 120 : 80);
    }

    els.btnMetronome.addEventListener('click', () => {
        STATE.metronomeEnabled = !STATE.metronomeEnabled;
        els.metronomeLed.classList.toggle('metronome-led-active', STATE.metronomeEnabled);
        setupMetronomeSchedule();
    });

    els.btnPlay.onclick = async () => {
        await ensureToneContextRunning();
        if (STATE.isPlaying) {
            Tone.Transport.pause();
            STATE.isPlaying = false;
            els.iconPlay.classList.remove('hidden');
            els.iconPause.classList.add('hidden');
        } else {
            if (!mainPart) syncTransport();
            Tone.Transport.start();
            STATE.isPlaying = true;
            els.iconPlay.classList.add('hidden');
            els.iconPause.classList.remove('hidden');
            const animate = () => {
                if (!STATE.isPlaying) return;
                updatePlayhead();
                requestAnimationFrame(animate);
            };
            requestAnimationFrame(animate);
        }
    };

    els.btnStop.onclick = () => {
        Tone.Transport.stop();
        STATE.isPlaying = false;
        STATE.currentBeat = 0;
        els.iconPlay.classList.remove('hidden');
        els.iconPause.classList.add('hidden');
        const { scrollLeft } = getViewportInfo();
        els.playhead.style.transform = `translateX(${0 - scrollLeft}px)`;
        els.timeDisplay.innerText = '0:0:0';
    };

    els.btnRewind.onclick = () => {
        Tone.Transport.position = 0;
        STATE.currentBeat = 0;
        const { scrollLeft } = getViewportInfo();
        els.playhead.style.transform = `translateX(${0 - scrollLeft}px)`;
        els.timeDisplay.innerText = '0:0:0';
    };

    els.btnClear.onclick = () => {
        if (confirm("Clear all notes?")) {
            STATE.notes = [];
            STATE.selectedNotes.clear();
            drawNotes();
            drawVelocityLane();
            syncTransport();
            STATE.hasPendingHistorySnapshot = true;
            captureHistorySnapshot();
        }
    };

    els.bpmInput.onchange = (e) => {
        const val = Math.max(30, Math.min(300, parseInt(e.target.value)));
        STATE.bpm = val;
        Tone.Transport.bpm.value = val;
        syncTransport();
        STATE.hasPendingHistorySnapshot = true;
        captureHistorySnapshot();
    };

    ['select', 'pencil', 'eraser'].forEach(t => {
        document.getElementById(`tool-${t}`).onclick = (e) => {
            document.querySelectorAll('.tool-btn').forEach(b => {
                b.classList.remove('active', 'bg-teal-500/20', 'text-teal-400', 'border-teal-500/50');
                b.classList.add('text-gray-400', 'border-transparent');
            });
            e.target.classList.add('active', 'bg-teal-500/20', 'text-teal-400', 'border-teal-500/50');
            e.target.classList.remove('text-gray-400', 'border-transparent');
            STATE.currentTool = t;
        };
    });

    function captureHistorySnapshot() {
        if (HISTORY.isRestoring) return;
        const snapshot = {
            notes: STATE.notes.map(n => ({ ...n })),
            bpm: STATE.bpm,
            beatWidth: CONFIG.beatWidth,
            rowHeight: CONFIG.rowHeight
        };
        HISTORY.undoStack.push(snapshot);
        if (HISTORY.undoStack.length > HISTORY.maxLength) HISTORY.undoStack.shift();
        HISTORY.redoStack.length = 0;
    }

    function restoreSnapshot(snapshot) {
        HISTORY.isRestoring = true;
        STATE.notes = snapshot.notes.map(n => ({ ...n }));
        STATE.bpm = snapshot.bpm;
        CONFIG.beatWidth = snapshot.beatWidth;
        CONFIG.rowHeight = snapshot.rowHeight;
        els.bpmInput.value = STATE.bpm;
        Tone.Transport.bpm.value = STATE.bpm;
        recalcWorldDimensions();
        generateKeys();
        resizeOverlayCanvases();
        syncTransport();
        STATE.selectedNotes.clear();
        HISTORY.isRestoring = false;
    }

    function undo() {
        if (HISTORY.undoStack.length <= 1) return;
        const current = HISTORY.undoStack.pop();
        HISTORY.redoStack.push(current);
        const prev = HISTORY.undoStack[HISTORY.undoStack.length - 1];
        restoreSnapshot(prev);
    }

    function redo() {
        if (HISTORY.redoStack.length === 0) return;
        const snap = HISTORY.redoStack.pop();
        HISTORY.undoStack.push(snap);
        restoreSnapshot(snap);
    }

    function copySelectionToClipboard() {
        if (STATE.selectedNotes.size === 0) return;
        const selected = STATE.notes.filter(n => STATE.selectedNotes.has(n.id));
        if (selected.length === 0) return;
        const minStart = Math.min(...selected.map(n => n.start));
        STATE.clipboard = {
            notes: selected.map(n => ({
                row: n.row,
                startOffset: n.start - minStart,
                duration: n.duration,
                velocity: n.velocity
            }))
        };
    }

    function getPasteTargetBeat() {
        if (STATE.lastPointerBeat != null) return snapBeat(STATE.lastPointerBeat);
        if (STATE.currentBeat != null) return snapBeat(STATE.currentBeat);
        return 0;
    }

    function pasteFromClipboard() {
        if (!STATE.clipboard || !STATE.clipboard.notes || STATE.clipboard.notes.length === 0) return;
        const baseBeat = getPasteTargetBeat();
        const newNotes = [];
        STATE.clipboard.notes.forEach(tpl => {
            const start = Math.max(0, baseBeat + tpl.startOffset);
            const n = {
                id: generateNoteId(),
                row: tpl.row,
                start,
                duration: tpl.duration,
                velocity: tpl.velocity
            };
            STATE.notes.push(n);
            newNotes.push(n);
        });
        STATE.selectedNotes = new Set(newNotes.map(n => n.id));
        drawNotes();
        drawVelocityLane();
        syncTransport();
        STATE.hasPendingHistorySnapshot = true;
        captureHistorySnapshot();
    }

    window.addEventListener('keydown', (e) => {
        const tag = e.target.tagName;
        const isTyping = tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable;

        if (!isTyping && e.code === 'Space') {
            e.preventDefault();
            els.btnPlay.click();
        }
        if (!isTyping && (e.code === 'Delete' || e.code === 'Backspace')) {
            if (STATE.selectedNotes.size > 0) {
                STATE.selectedNotes.forEach(id => deleteNote(id));
                if (STATE.hasPendingHistorySnapshot) {
                    captureHistorySnapshot();
                    STATE.hasPendingHistorySnapshot = false;
                }
            }
        }
        if (!isTyping && (e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') {
            e.preventDefault();
            undo();
        }
        if (!isTyping && (e.ctrlKey || e.metaKey) &&
            (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) {
            e.preventDefault();
            redo();
        }
        if (!isTyping && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
            e.preventDefault();
            copySelectionToClipboard();
        }
        if (!isTyping && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') {
            e.preventDefault();
            pasteFromClipboard();
        }
    });

    els.btnExport.onclick = () => {
        const data = { bpm: STATE.bpm, notes: STATE.notes };
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'composition_' + Date.now() + '.json';
        a.click();
    };

    if (els.btnImportJson && els.importJsonInput) {
        els.btnImportJson.addEventListener('click', () => {
            els.importJsonInput.value = '';
            els.importJsonInput.click();
        });
        els.importJsonInput.addEventListener('change', (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    loadJsonProjectFromData(data);
                    alert('JSON project imported!');
                } catch (err) {
                    console.error(err);
                    alert('Failed to import JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
        });
    }

    if (els.btnExportMidi) {
        els.btnExportMidi.addEventListener('click', () => {
            try {
                exportMidiFile();
            } catch (err) {
                console.error(err);
                alert('Failed to export MIDI: ' + err.message);
            }
        });
    }

    if (els.btnImportMidi && els.importMidiInput) {
        els.btnImportMidi.addEventListener('click', () => {
            els.importMidiInput.value = '';
            els.importMidiInput.click();
        });
        els.importMidiInput.addEventListener('change', (e) => {
            const file = e.target.files?.[0];
            if (!file) return;
            file.arrayBuffer()
                .then(buffer => {
                    const parsed = parseMidiFile(buffer);
                    applyImportedMidiData(parsed);
                    alert('MIDI imported!');
                })
                .catch(err => {
                    console.error(err);
                    alert('Failed to import MIDI: ' + err.message);
                });
        });
    }

    // ===== Render audio bounce (temporarily disables looping) =====
    document.getElementById('btn-render').onclick = async () => {
        if (STATE.notes.length === 0) {
            alert("No notes to render!");
            return;
        }
        const btn = document.getElementById('btn-render');
        const oldText = btn.innerText;
        btn.innerText = "RENDERING...";
        btn.disabled = true;
        btn.classList.add('opacity-50', 'cursor-not-allowed');

        try {
            const recorder = new Tone.Recorder();
            pianoSampler.connect(recorder);

            if (STATE.isPlaying) els.btnStop.click();
            await new Promise(r => setTimeout(r, 200));

            // Keep Tone.Transport aligned with the sequencer before bouncing.
            syncTransport();

            // Compute how many beats need to be exported based on the final note.
            const lastEndBeat = STATE.notes.reduce((max, n) => Math.max(max, n.start + n.duration), 0);
            const tailBeats = 2; // Add a short tail so releases and FX can decay cleanly.
            const totalBeats = lastEndBeat + tailBeats;
            const durationSecs = totalBeats * (60 / STATE.bpm);

            // Remember the user's previous loop boundaries.
            const prevLoop = Tone.Transport.loop;
            const prevLoopStart = Tone.Transport.loopStart;
            const prevLoopEnd = Tone.Transport.loopEnd;

            // Disable looping while bouncing so the recorder captures a single pass.
            Tone.Transport.loop = false;
            Tone.Transport.loopStart = 0;
            Tone.Transport.loopEnd = getTransportTime(totalBeats);

            recorder.start();
            Tone.Transport.stop();
            Tone.Transport.position = 0;
            Tone.Transport.start();

            await new Promise(resolve => setTimeout(resolve, (durationSecs * 1000) + 500));

            Tone.Transport.stop();
            const recording = await recorder.stop();

            // Restore the saved loop settings and resync afterward.
            Tone.Transport.loop = prevLoop;
            Tone.Transport.loopStart = prevLoopStart;
            Tone.Transport.loopEnd = prevLoopEnd;
            syncTransport();

            const url = URL.createObjectURL(recording);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'composition_' + Date.now() + '.webm';
            a.click();
        } catch (e) {
            console.error(e);
            alert("Rendering failed. See console.");
        } finally {
            btn.innerText = oldText;
            btn.disabled = false;
            btn.classList.remove('opacity-50', 'cursor-not-allowed');
        }
    };

    document.body.addEventListener('dragover', e => e.preventDefault());
    document.body.addEventListener('drop', e => {
        e.preventDefault();
        if (e.dataTransfer.files.length > 0) {
            const file = e.dataTransfer.files[0];
            const name = file.name ? file.name.toLowerCase() : '';
            if (name.endsWith('.mid') || name.endsWith('.midi')) {
                file.arrayBuffer()
                    .then(buffer => {
                        const parsed = parseMidiFile(buffer);
                        applyImportedMidiData(parsed);
                        alert('MIDI imported!');
                    })
                    .catch(err => alert('Invalid MIDI file: ' + err.message));
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    loadJsonProjectFromData(data);
                    alert("Project loaded successfully!");
                } catch (err) {
                    alert("Invalid JSON file");
                }
            };
            reader.readAsText(file);
        }
    });

    function loadJsonProjectFromData(data) {
        if (!data || !Array.isArray(data.notes)) {
            throw new Error('Missing notes array');
        }
        const normalizedNotes = data.notes.map(n => {
            const sourceRow = typeof n.row === 'number'
                ? n.row
                : (typeof n.midi === 'number' ? getRowFromMidi(n.midi) : 0);
            const start = Number(n.start);
            const duration = Number(n.duration);
            return {
                id: generateNoteId(),
                row: clampRow(sourceRow),
                start: Number.isFinite(start) ? start : 0,
                duration: Math.max(STATE.snapToGrid, Number.isFinite(duration) ? duration : STATE.snapToGrid),
                velocity: n.velocity != null ? n.velocity : 0.8,
                part: n.part
            };
        });
        applyImportedProject(normalizedNotes, data.bpm);
    }

    function exportMidiFile() {
        if (!STATE.notes.length) {
            alert('No notes to export!');
            return;
        }
        const midiData = buildMidiFile(STATE.notes, STATE.bpm);
        const blob = new Blob([midiData], { type: 'audio/midi' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'composition_' + Date.now() + '.mid';
        a.click();
    }

    function buildMidiFile(notes, bpm) {
        const ticksPerBeat = 480;
        const tempoUs = Math.max(1, Math.round(60000000 / (bpm || 120)));
        const events = [];
        notes.forEach(note => {
            const midi = getMidiFromRow(note.row);
            const startTick = Math.max(0, Math.round(note.start * ticksPerBeat));
            const durationTicks = Math.max(1, Math.round(note.duration * ticksPerBeat));
            const velocity = Math.max(1, Math.min(127, Math.round((note.velocity != null ? note.velocity : 0.8) * 127)));
            events.push({ tick: startTick, type: 'on', midi, velocity });
            events.push({ tick: startTick + durationTicks, type: 'off', midi, velocity: 0 });
        });
        events.sort((a, b) => a.tick - b.tick || (a.type === 'off' ? -1 : 1));

        const track = [];
        const pushVar = (value) => track.push(...encodeVariableLength(value));

        // Track name
        pushVar(0);
        const nameBytes = asciiBytes('PIANOROLL');
        track.push(0xFF, 0x03, nameBytes.length, ...nameBytes);

        // Tempo meta
        pushVar(0);
        track.push(0xFF, 0x51, 0x03, (tempoUs >> 16) & 0xFF, (tempoUs >> 8) & 0xFF, tempoUs & 0xFF);

        // Program change (acoustic grand)
        pushVar(0);
        track.push(0xC0, 0x00);

        let lastTick = 0;
        events.forEach(evt => {
            const delta = evt.tick - lastTick;
            pushVar(delta);
            lastTick = evt.tick;
            if (evt.type === 'on') {
                track.push(0x90, evt.midi & 0x7F, evt.velocity);
            } else {
                track.push(0x80, evt.midi & 0x7F, 0);
            }
        });

        // End of track
        track.push(0x00, 0xFF, 0x2F, 0x00);

        const header = new Uint8Array([
            0x4d, 0x54, 0x68, 0x64, // MThd
            0x00, 0x00, 0x00, 0x06,
            0x00, 0x00, // format 0
            0x00, 0x01, // one track
            (ticksPerBeat >> 8) & 0xFF,
            ticksPerBeat & 0xFF
        ]);

        const trackLength = track.length;
        const trackHeader = new Uint8Array([
            0x4d, 0x54, 0x72, 0x6b,
            (trackLength >> 24) & 0xFF,
            (trackLength >> 16) & 0xFF,
            (trackLength >> 8) & 0xFF,
            trackLength & 0xFF
        ]);

        const midiData = new Uint8Array(header.length + trackHeader.length + trackLength);
        midiData.set(header, 0);
        midiData.set(trackHeader, header.length);
        midiData.set(track, header.length + trackHeader.length);
        return midiData;
    }

    function encodeVariableLength(value) {
        let buffer = value & 0x7F;
        const bytes = [];
        while ((value >>= 7)) {
            buffer <<= 8;
            buffer |= ((value & 0x7F) | 0x80);
        }
        while (true) {
            bytes.push(buffer & 0xFF);
            if (buffer & 0x80) buffer >>= 8;
            else break;
        }
        return bytes;
    }

    function asciiBytes(str) {
        return Array.from(str).map(ch => ch.charCodeAt(0) & 0x7F);
    }

    function parseMidiFile(buffer) {
        const data = new Uint8Array(buffer);
        let offset = 0;

        function readString(len) {
            const str = String.fromCharCode(...data.slice(offset, offset + len));
            offset += len;
            return str;
        }

        function readUint32() {
            const value = (data[offset] << 24) | (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3];
            offset += 4;
            return value >>> 0;
        }

        function readUint16() {
            const value = (data[offset] << 8) | data[offset + 1];
            offset += 2;
            return value;
        }

        function readVar(offsetPointer) {
            let result = 0;
            let consumed = 0;
            let byte;
            do {
                byte = data[offsetPointer + consumed];
                result = (result << 7) | (byte & 0x7F);
                consumed++;
            } while (byte & 0x80);
            return [result, consumed];
        }

        if (readString(4) !== 'MThd') throw new Error('Invalid MIDI header');
        const headerLen = readUint32();
        const format = readUint16();
        const nTracks = readUint16();
        const division = readUint16();
        if (headerLen > 6) offset += headerLen - 6;
        if (division & 0x8000) throw new Error('SMPTE time format not supported');
        const ticksPerBeat = division || 480;

        let tempo = 500000; // default 120 BPM
        const collected = [];

        for (let trackIndex = 0; trackIndex < nTracks && offset < data.length; trackIndex++) {
            const chunkId = readString(4);
            const length = readUint32();
            const chunkEnd = offset + length;
            if (chunkId !== 'MTrk') {
                offset = chunkEnd;
                continue;
            }

            let tick = 0;
            let runningStatus = null;
            const activeNotes = {};

            while (offset < chunkEnd) {
                const [delta, deltaLen] = readVar(offset);
                offset += deltaLen;
                tick += delta;

                let statusByte = data[offset];
                if (statusByte & 0x80) {
                    runningStatus = statusByte;
                    offset++;
                } else if (runningStatus != null) {
                    statusByte = runningStatus;
                } else {
                    throw new Error('Corrupt MIDI event stream');
                }

                if (statusByte === 0xFF) {
                    const metaType = data[offset++];
                    const [metaLen, metaLenSize] = readVar(offset);
                    offset += metaLenSize;
                    if (metaType === 0x51 && metaLen === 3) {
                        tempo = (data[offset] << 16) | (data[offset + 1] << 8) | data[offset + 2];
                    }
                    offset += metaLen;
                    continue;
                }

                if (statusByte === 0xF0 || statusByte === 0xF7) {
                    const [syxLen, syxLenSize] = readVar(offset);
                    offset += syxLenSize + syxLen;
                    continue;
                }

                const eventType = statusByte & 0xF0;
                const channel = statusByte & 0x0F;
                const param1 = data[offset++];
                let param2 = 0;
                if (eventType !== 0xC0 && eventType !== 0xD0) {
                    param2 = data[offset++];
                }
                const key = `${channel}_${param1}`;
                if (eventType === 0x90) {
                    if (param2 > 0) {
                        activeNotes[key] = { tick, velocity: Math.max(0.05, param2 / 127) };
                    } else if (activeNotes[key]) {
                        const start = activeNotes[key];
                        collected.push({
                            midi: param1,
                            startTick: start.tick,
                            durationTicks: Math.max(1, tick - start.tick),
                            velocity: start.velocity
                        });
                        delete activeNotes[key];
                    }
                } else if (eventType === 0x80) {
                    if (activeNotes[key]) {
                        const start = activeNotes[key];
                        collected.push({
                            midi: param1,
                            startTick: start.tick,
                            durationTicks: Math.max(1, tick - start.tick),
                            velocity: start.velocity
                        });
                        delete activeNotes[key];
                    }
                }
            }

            offset = chunkEnd;
        }

        if (!collected.length) {
            throw new Error('No note data found');
        }

        const notes = collected.map(n => ({
            midi: n.midi,
            start: n.startTick / ticksPerBeat,
            duration: n.durationTicks / ticksPerBeat,
            velocity: n.velocity
        })).sort((a, b) => a.start - b.start);

        return { notes, bpm: 60000000 / tempo };
    }

    function applyImportedMidiData(parsed) {
        if (!parsed || !Array.isArray(parsed.notes) || parsed.notes.length === 0) {
            throw new Error('MIDI file contained no playable notes');
        }
        const normalizedNotes = parsed.notes.map(n => ({
            id: generateNoteId(),
            row: clampRow(getRowFromMidi(n.midi)),
            start: Number.isFinite(n.start) ? n.start : 0,
            duration: Math.max(STATE.snapToGrid, Number.isFinite(n.duration) ? n.duration : STATE.snapToGrid),
            velocity: n.velocity != null ? Math.max(0.1, Math.min(1, n.velocity)) : 0.8
        }));
        applyImportedProject(normalizedNotes, parsed.bpm);
    }

    els.gridArea.addEventListener('wheel', (e) => {
        const { scrollLeft, scrollTop } = getViewportInfo();
        const rect = els.gridArea.getBoundingClientRect();
        const pointerX = e.clientX - rect.left;
        const pointerY = e.clientY - rect.top;
        const worldX = scrollLeft + pointerX;
        const worldY = scrollTop + pointerY;

        if (e.ctrlKey || e.altKey) {
            e.preventDefault();
            if (e.ctrlKey) {
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                let newBeatWidth = CONFIG.beatWidth * zoomFactor;
                newBeatWidth = Math.min(CONFIG.zoom.maxBeatWidth, Math.max(CONFIG.zoom.minBeatWidth, newBeatWidth));
                const beatAtCursor = worldX / CONFIG.beatWidth;
                CONFIG.beatWidth = newBeatWidth;
                recalcWorldDimensions();
                const newWorldX = beatAtCursor * CONFIG.beatWidth;
                els.scrollContainer.scrollLeft = newWorldX - pointerX;
            } else if (e.altKey) {
                const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                let newRowHeight = CONFIG.rowHeight * zoomFactor;
                newRowHeight = Math.min(CONFIG.zoom.maxRowHeight, Math.max(CONFIG.zoom.minRowHeight, newRowHeight));
                const rowAtCursor = worldY / CONFIG.rowHeight;
                CONFIG.rowHeight = newRowHeight;
                totalHeight = totalKeys * CONFIG.rowHeight;
                els.content.style.height = `${totalHeight}px`;
                generateKeys();
                const newWorldY = rowAtCursor * CONFIG.rowHeight;
                els.scrollContainer.scrollTop = newWorldY - pointerY;
            }
            resizeOverlayCanvases();
            drawGrid();
            drawNotes();
            drawVelocityLane();
            renderRuler();
            STATE.hasPendingHistorySnapshot = true;
            captureHistorySnapshot();
        } else {
            e.preventDefault();
            if (e.shiftKey) {
                els.scrollContainer.scrollLeft += e.deltaY;
            } else {
                els.scrollContainer.scrollTop += e.deltaY;
                els.scrollContainer.scrollLeft += e.deltaX;
            }
        }
    }, { passive: false });

    function renderAll() {
        drawGrid();
        drawNotes();
        drawVelocityLane();
        renderRuler();
    }

    window.addEventListener('resize', () => {
        resizeOverlayCanvases();
    });

    document.getElementById('init-btn').onclick = () => {
        els.startOverlay.classList.add('hidden');
        els.loading.classList.remove('hidden');
        setTimeout(() => {
            initAudio().then(() => {
                initUI();
                syncTransport();
                autoGenerateFromUI();
            });
        }, 100);
    };

    window.onload = () => {
        els.startOverlay.classList.remove('hidden');
    };

    // ==========================
    // AUTO COMPOSE helpers & generation pipeline
    // ==========================

    function buildMinorScaleSets(rootPc) {
        const natDeg = [0, 2, 3, 5, 7, 8, 10];
        const harmDeg = [0, 2, 3, 5, 7, 8, 11];
        const melDeg = [0, 2, 3, 5, 7, 9, 11];
        const natural = natDeg.map(d => (rootPc + d) % 12);
        const harmonic = harmDeg.map(d => (rootPc + d) % 12);
        const melodicAsc = melDeg.map(d => (rootPc + d) % 12);

        const modernSet = new Set(natural.concat(harmonic, melodicAsc));
        const modern = Array.from(modernSet).sort((a, b) => ((a - b + 12) % 12));

        return { natural, harmonic, melodicAsc, modern };
    }

    function parseKey(rootName, mode) {
        const keyName = rootName.toUpperCase();
        const rootPc = NOTE_TO_SEMITONE[keyName];
        if (rootPc == null) throw new Error('Invalid key: ' + rootName);

        const keyRootMidi = 60 + rootPc;

        const scaleSets = (mode === 'minor')
            ? buildMinorScaleSets(rootPc)
            : { major: [0, 2, 4, 5, 7, 9, 11].map(d => (rootPc + d) % 12) };

        const defaultScale = (mode === 'minor') ? scaleSets.natural : scaleSets.major;

        return {
            rootName,
            mode,
            rootPc,
            keyRootMidi,
            scaleSets,
            scalePcs: defaultScale
        };
    }

    function parseChordSymbol(sym, key) {
        let s = sym.trim();
        if (!s) return null;

        let m = s.match(/^([A-Ga-g])([#b]?)(.*)$/);
        if (m) {
            const letter = m[1].toUpperCase();
            const accidental = (m[2] || '').replace('b', 'B');
            const rest = (m[3] || '').toLowerCase();
            const rootNameRaw = letter + accidental;
            const rootPc = NOTE_TO_SEMITONE[rootNameRaw];
            if (rootPc == null) return null;
            let quality = 'maj';
            if (rest.startsWith('m') && !rest.startsWith('maj')) quality = 'min';
            const intervals = quality === 'maj' ? [0, 4, 7] : [0, 3, 7];
            const display = PC_TO_NOTE[rootPc] + (quality === 'min' ? 'm' : '');
            return { symbol: s, rootPc, quality, intervals, display };
        }

        const romanMap = { 'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11 };
        m = s.match(/^([ivIV]+)(.*)$/);
        if (m && key) {
            const numeral = m[1];
            const rest = (m[2] || '').toLowerCase();
            const isUpper = numeral === numeral.toUpperCase();
            const degreeName = numeral.toUpperCase();
            const baseDegreePcOffset = romanMap[degreeName];
            if (baseDegreePcOffset == null) return null;
            const rootPc = (key.rootPc + baseDegreePcOffset) % 12;
            let quality = isUpper ? 'maj' : 'min';
            if (rest.startsWith('m') && !rest.startsWith('maj')) quality = 'min';
            const intervals = quality === 'maj' ? [0, 4, 7] : [0, 3, 7];
            const display = PC_TO_NOTE[rootPc] + (quality === 'min' ? 'm' : '');
            return { symbol: s, rootPc, quality, intervals, display };
        }
        return null;
    }

    function parseChordProgression(chordStr, key) {
        if (!chordStr) return [];
        const tokens = chordStr
            .split(/[\|\n,]+/g)
            .map(t => t.trim())
            .filter(Boolean);
        const chords = [];
        let invalid = [];
        tokens.forEach(t => {
            const chord = parseChordSymbol(t, key);
            if (chord) chords.push(chord);
            else invalid.push(t);
        });
        if (chords.length === 0 && invalid.length > 0) {
            alert('Chord progression tokens invalid: ' + invalid.join(', '));
        }
        return chords;
    }

    function randomChoice(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }
    function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function randomFloat(min, max) {
        return Math.random() * (max - min) + min;
    }

    function makeChord(rootPc, quality) {
        const intervals = quality === 'maj' ? [0, 4, 7] : [0, 3, 7];
        const display = PC_TO_NOTE[rootPc] + (quality === 'min' ? 'm' : '');
        return { symbol: display, rootPc, quality, intervals, display };
    }

    function chordSequenceToString(chords) {
        return chords.map(ch => ch.display || ch.symbol || '').join(' | ');
    }

    function pickVerseAlteration(ch, key) {
        if (key.mode !== 'minor') return null;
        const relPc = (ch.rootPc - key.rootPc + 12) % 12;
        let candidates = [];
        switch (relPc) {
            case 0:
                candidates = [
                    makeChord((key.rootPc + 3) % 12, 'maj'),
                    makeChord((key.rootPc + 8) % 12, 'maj')
                ];
                break;
            case 3:
                candidates = [
                    makeChord(key.rootPc, 'min'),
                    makeChord((key.rootPc + 8) % 12, 'maj')
                ];
                break;
            case 5:
                candidates = [
                    makeChord((key.rootPc + 8) % 12, 'maj'),
                    makeChord((key.rootPc + 10) % 12, 'maj')
                ];
                break;
            case 7:
                candidates = [
                    makeChord((key.rootPc + 10) % 12, 'maj'),
                    makeChord((key.rootPc + 3) % 12, 'maj')
                ];
                break;
            case 8:
                candidates = [
                    makeChord((key.rootPc + 5) % 12, 'min'),
                    makeChord((key.rootPc + 10) % 12, 'maj')
                ];
                break;
            case 10:
                candidates = [
                    makeChord((key.rootPc + 7) % 12, 'maj'),
                    makeChord((key.rootPc + 3) % 12, 'maj')
                ];
                break;
            default:
                break;
        }
        if (!candidates.length) return null;
        return randomChoice(candidates);
    }

    function pickChorusAlteration(ch, key) {
        if (key.mode !== 'minor') return null;
        const relPc = (ch.rootPc - key.rootPc + 12) % 12;
        let candidates = [];
        switch (relPc) {
            case 0:
                candidates = [
                    makeChord((key.rootPc + 3) % 12, 'maj'),
                    makeChord((key.rootPc + 8) % 12, 'maj'),
                    makeChord((key.rootPc + 10) % 12, 'maj')
                ];
                break;
            case 3:
                candidates = [
                    makeChord((key.rootPc + 8) % 12, 'maj'),
                    makeChord(key.rootPc, 'min')
                ];
                break;
            case 5:
                candidates = [
                    makeChord((key.rootPc + 10) % 12, 'maj'),
                    makeChord((key.rootPc + 7) % 12, 'maj')
                ];
                break;
            case 7:
                candidates = [
                    makeChord((key.rootPc + 10) % 12, 'maj'),
                    makeChord((key.rootPc + 3) % 12, 'maj')
                ];
                break;
            case 8:
                candidates = [
                    makeChord((key.rootPc + 3) % 12, 'maj'),
                    makeChord((key.rootPc + 10) % 12, 'maj')
                ];
                break;
            case 10:
                candidates = [
                    makeChord((key.rootPc + 7) % 12, 'maj'),
                    makeChord((key.rootPc + 3) % 12, 'maj')
                ];
                break;
            default:
                break;
        }
        if (!candidates.length) return null;
        return randomChoice(candidates);
    }

    function pickMajorAlteration(ch, key, role) {
        if (key.mode !== 'major') return null;
        const relPc = (ch.rootPc - key.rootPc + 12) % 12;
        const wrapPc = (offset) => (key.rootPc + offset + 12) % 12;
        const push = (arr, offset, quality) => {
            arr.push(makeChord(wrapPc(offset), quality));
            return arr;
        };
        let candidates = [];
        switch (relPc) {
            case 0: // I
                push(candidates, 5, 'maj'); // IV
                push(candidates, 9, 'min'); // vi
                if (role === 'chorus') push(candidates, 7, 'maj'); // V
                break;
            case 2: // ii
                push(candidates, 7, 'maj'); // V
                push(candidates, 9, 'min'); // vi
                break;
            case 4: // iii
                push(candidates, 0, 'maj'); // I
                push(candidates, 2, 'min'); // ii
                break;
            case 5: // IV
                push(candidates, 7, 'maj'); // V
                push(candidates, 9, 'min'); // vi
                break;
            case 7: // V
                push(candidates, 2, 'min'); // ii
                push(candidates, 0, 'maj'); // I
                push(candidates, 10, 'maj'); // bVII lift
                break;
            case 9: // vi
                push(candidates, 0, 'maj'); // I
                push(candidates, 5, 'maj'); // IV
                break;
            case 10: // bVII
                push(candidates, 0, 'maj'); // I
                push(candidates, 5, 'maj'); // IV
                break;
            default:
                push(candidates, 5, 'maj');
                break;
        }
        if (!candidates.length) return null;
        const unique = [];
        const seen = new Set();
        candidates.forEach(c => {
            const keyStr = `${c.rootPc}-${c.quality}`;
            if (!seen.has(keyStr)) {
                seen.add(keyStr);
                unique.push(c);
            }
        });
        return randomChoice(unique);
    }

    function mutateChordSequence(chords, key, role) {
        if (!chords.length) return chords;
        let result = chords.map(ch => ({ ...ch }));

        if (result.length > 1 && Math.random() < 0.6) {
            const rot = Math.floor(Math.random() * result.length);
            result = result.slice(rot).concat(result.slice(0, rot));
        }

        for (let i = 0; i < result.length; i++) {
            const ch = result[i];
            if (!ch) continue;
            const r = Math.random();
            let alt = null;
            if (key.mode === 'minor') {
                if (role === 'verse') {
                    if (r < 0.25) alt = pickVerseAlteration(ch, key);
                } else {
                    if (r < 0.3) alt = pickChorusAlteration(ch, key);
                }
            } else {
                const threshold = role === 'chorus' ? 0.55 : 0.35;
                if (r < threshold) {
                    alt = pickMajorAlteration(ch, key, role);
                }
            }
            if (alt) result[i] = alt;
        }
        return result;
    }

    function createSecondaryDominant(targetChord, key) {
        if (!targetChord) return null;
        const approachPc = (targetChord.rootPc + 7) % 12;
        return makeChord(approachPc, 'maj');
    }

    function decorateChorusChords(chords, key, intent) {
        if (!chords || chords.length === 0) return chords;
        const result = [];
        const color = (intent && intent.harmonicColor) || {};
        for (let i = 0; i < chords.length; i++) {
            const chord = { ...chords[i] };
            const relPc = (chord.rootPc - key.rootPc + 12) % 12;
            if (key.mode === 'major' && Math.random() < 0.35) {
                if (relPc === 0 && Math.random() < 0.5) {
                    const liftPc = (key.rootPc + 2) % 12;
                    result.push(makeChord(liftPc, 'maj'));
                }
                if (relPc === 4 && Math.random() < 0.6) {
                    const susPc = (chord.rootPc + 2) % 12;
                    result.push(makeChord(susPc, 'maj'));
                }
            }
            result.push(chord);
            const next = chords[(i + 1) % chords.length];
            const secDomChance = color.secDomChance != null ? color.secDomChance : 0.3;
            if (Math.random() < secDomChance && next) {
                const approach = createSecondaryDominant(next, key);
                if (approach) result.push(approach);
            }
            if (color.borrowIVm && relPc === 5 && Math.random() < 0.4) {
                result.push(makeChord((key.rootPc + 5) % 12, 'min'));
            }
            if (color.addbVII && relPc === 0 && Math.random() < 0.35) {
                result.push(makeChord((key.rootPc + 10) % 12, 'maj'));
            }
            if (color.modalShiftChance && Math.random() < color.modalShiftChance) {
                const shiftPc = key.mode === 'major' ? (key.rootPc + 3) % 12 : (key.rootPc + 4) % 12;
                result.push(makeChord(shiftPc, chord.quality === 'maj' ? 'min' : 'maj'));
            }
        }
        return result;
    }

    function quantizeMidiToScale(midi, scalePcs) {
        const pc = midi % 12;
        if (scalePcs.includes(pc)) return midi;
        let bestPc = pc, bestDist = 99;
        scalePcs.forEach(spc => {
            const d = Math.min((spc - pc + 12) % 12, (pc - spc + 12) % 12);
            if (d < bestDist) {
                bestDist = d;
                bestPc = spc;
            }
        });
        let bestMidi = midi; bestDist = 99;
        for (let o = -1; o <= 1; o++) {
            const cand = (Math.floor(midi / 12) + o) * 12 + bestPc;
            const d = Math.abs(cand - midi);
            if (d < bestDist) {
                bestDist = d;
                bestMidi = cand;
            }
        }
        return bestMidi;
    }

    function quantizeToScale(midi, key) {
        return quantizeMidiToScale(midi, key.scalePcs);
    }

    function selectScalePcsForContext({ key, chord, beatInBar, isCadence, prevMidi, currMidi, sectionType }) {
        if (key.mode !== 'minor') {
            return key.scaleSets.major;
        }
        const sets = key.scaleSets;
        let scale = sets.natural;

        const direction = (prevMidi != null && currMidi != null)
            ? Math.sign(currMidi - prevMidi)
            : 0;

        let relPc = null;
        let isDominant = false;
        let isSubdominant = false;
        let isFlatVII = false;

        if (chord) {
            relPc = (chord.rootPc - key.rootPc + 12) % 12;
            isDominant = (relPc === 7);
            isSubdominant = (relPc === 5 || relPc === 2);
            isFlatVII = (relPc === 10);
        }

        if (isCadence || isDominant || (sectionType && sectionType.startsWith('pre'))) {
            scale = sets.harmonic;
        } else if (direction > 0 && beatInBar >= 2) {
            scale = sets.melodicAsc;
        } else if (isFlatVII || isSubdominant) {
            scale = sets.modern;
        } else {
            scale = sets.natural;
        }
        return scale;
    }

    function getChordTonePcs(key, chord) {
        const pcs = chord.intervals.map(intv => (chord.rootPc + intv) % 12);
        if (key.mode === 'minor') {
            const relPc = (chord.rootPc - key.rootPc + 12) % 12;
            if (relPc === 7 || relPc === 0) {
                const seventh = chord.quality === 'maj' ? 11 : 10;
                pcs.push((chord.rootPc + seventh) % 12);
            }
        } else {
            const relPc = (chord.rootPc - key.rootPc + 12) % 12;
            if (chord.quality === 'maj' && relPc !== 5) {
                pcs.push((chord.rootPc + 11) % 12);
            }
        }
        return Array.from(new Set(pcs));
    }

    function getAllowedTensionsPcs(key, chord, chordTonePcs) {
        let scale;
        if (key.mode === 'minor') {
            scale = key.scaleSets.modern;
        } else {
            scale = key.scaleSets.major;
        }
        let tensions = scale.filter(pc => !chordTonePcs.includes(pc));

        if (tensions.length > 4) {
            const rootPc = chord.rootPc;
            tensions.sort((a, b) => {
                const da = Math.min((a - rootPc + 12) % 12, (rootPc - a + 12) % 12);
                const db = Math.min((b - rootPc + 12) % 12, (rootPc - b + 12) % 12);
                return da - db;
            });
            tensions = tensions.slice(0, 4);
        }
        return tensions;
    }

    function snapMidiToNearestPc(midi, pcs) {
        if (!pcs || pcs.length === 0) return midi;
        let bestMidi = midi;
        let bestDist = 1e9;
        pcs.forEach(pc => {
            for (let o = -2; o <= 2; o++) {
                const cand = (Math.floor(midi / 12) + o) * 12 + pc;
                const d = Math.abs(cand - midi);
                if (d < bestDist) {
                    bestDist = d;
                    bestMidi = cand;
                }
            }
        });
        return bestMidi;
    }

    function refineNoteWithHarmony(midi, ctx) {
        const { key, chord, isStrong } = ctx;
        const scalePcs = selectScalePcsForContext(ctx);
        let candidate = quantizeMidiToScale(midi, scalePcs);

        if (!chord) return candidate;

        const chordTonePcs = getChordTonePcs(key, chord);
        const tensionPcs = getAllowedTensionsPcs(key, chord, chordTonePcs);

        const pc = candidate % 12;
        const isChordTone = chordTonePcs.includes(pc);
        const isTension = tensionPcs.includes(pc);

        if (isStrong) {
            if (!isChordTone) {
                candidate = snapMidiToNearestPc(candidate, chordTonePcs);
            }
        } else {
            if (!isChordTone && !isTension) {
                candidate = snapMidiToNearestPc(candidate, chordTonePcs.concat(tensionPcs));
            }
        }

        // Force large melodic leaps to land on stable chord tones (scale degrees 1/3/5).
        const prevMidi = ctx.prevMidi ?? null;
        if (prevMidi != null) {
            const leapSize = Math.abs(candidate - prevMidi);
            if (leapSize >= 5) {
                const allowedLeapPcs = [0, 4, 7].map(intv => (chord.rootPc + intv) % 12);
                candidate = snapMidiToNearestPc(candidate, allowedLeapPcs);
            }
        }

        return candidate;
    }

    function getRangeInfo(key, range) {
        const rootMidi = 60 + key.rootPc;
        let center;
        if (range === 'low') {
            center = rootMidi - 7;
        } else if (range === 'mid') {
            center = rootMidi;
        } else {
            center = rootMidi + 5;
        }

        const downSpan = range === 'low' ? 7 : 8;
        const upSpan   = range === 'high' ? 8 : 7;

        const minMidi = Math.max(45, center - downSpan);
        const maxMidi = Math.min(84, center + upSpan);
        return { centerMidi: center, minMidi, maxMidi };
    }

    function clampMidiToRange(midi, rangeInfo) {
        return Math.min(rangeInfo.maxMidi, Math.max(rangeInfo.minMidi, midi));
    }

    function normalizePatternTo4(pattern) {
        let sum = pattern.reduce((a, b) => a + b, 0);
        if (Math.abs(sum - 4) < 1e-6) return pattern;
        let scaled = pattern.map(d => Math.max(0.25, Math.round(d * 16 / sum) / 4));
        sum = scaled.reduce((a, b) => a + b, 0);
        if (sum > 4) {
            scaled[scaled.length - 1] = Math.max(0.25, scaled[scaled.length - 1] - (sum - 4));
        } else if (sum < 4) {
            scaled[scaled.length - 1] += (4 - sum);
        }
        return scaled;
    }

    function pickMotifRhythm(density, isChorusMain) {
        const verseSparse = [
            [2, 2],
            [1, 1, 2],
            [1.5, 0.5, 2]
        ];
        const verseMedium = [
            [1, 0.5, 0.5, 2],
            [0.5, 0.5, 1, 2],
            [0.5, 0.5, 1, 0.5, 1.5]
        ];
        const verseDense = [
            [0.5, 0.5, 0.5, 0.5, 1, 1],
            [0.25, 0.25, 0.5, 1, 0.5, 1.5],
            [0.5, 0.5, 0.25, 0.75, 0.5, 1, 0.5]
        ];
        const verseSyncopated = [
            [0.75, 0.25, 1, 0.5, 1.5],
            [0.5, 1.5, 0.5, 0.5, 1],
            [0.5, 0.5, 0.5, 1, 0.75, 0.25, 0.5]
        ];

        const chorusBase = [
            [1, 0.5, 0.5, 1, 1],
            [0.5, 0.5, 1, 0.5, 0.5, 1],
            [0.75, 0.25, 1, 0.5, 0.5, 1]
        ];
        const chorusDense = [
            [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
            [0.25, 0.25, 0.5, 0.5, 0.25, 0.25, 0.5, 0.5, 1]
        ];
        const chorusPickup = [
            [0.25, 0.75, 1, 0.5, 0.5, 1],
            [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1],
            [0.75, 0.25, 0.75, 0.25, 1, 1]
        ];

        let group;
        if (isChorusMain) {
            if (density === 'sparse') group = chorusBase.slice();
            else if (density === 'dense') group = chorusBase.concat(chorusDense, chorusPickup);
            else group = chorusBase.concat(chorusDense.slice(0, 1), chorusPickup);
        } else {
            if (density === 'sparse') group = verseSparse.concat([verseSyncopated[0]]);
            else if (density === 'dense') group = verseMedium.concat(verseDense, verseSyncopated);
            else group = verseMedium.concat(verseSyncopated);
        }

        if (!isChorusMain && Math.random() < 0.4) {
            group = group.concat(verseSyncopated);
        } else if (isChorusMain && Math.random() < 0.4) {
            group = group.concat(chorusPickup);
        }

        let pattern = randomChoice(group).slice();

        if (!isChorusMain && Math.random() < 0.3) {
            const idx = Math.floor(Math.random() * pattern.length);
            const dur = pattern[idx];
            if (dur > 0.5) {
                const part = Math.max(0.25, Math.round((dur / 2) * 4) / 4);
                pattern[idx] = part;
                pattern.splice(idx + 1, 0, dur - part);
            }
        }

        return normalizePatternTo4(pattern);
    }

    const SECTION_VELOCITY_PROFILES = {
        intro:   { base: 0.75, peak: 0.9 },
        verse:   { base: 0.85, peak: 0.99 },
        pre:     { base: 0.9,  peak: 1.04 },
        chorus:  { base: 1.0,  peak: 1.1 },
        bridge:  { base: 0.92, peak: 1.05 },
        outro:   { base: 0.65, peak: 0.8 },
        default: { base: 0.85, peak: 0.98 }
    };

    function getSectionProfileKey(section) {
        if (!section || !section.type) return 'default';
        const type = section.type.toLowerCase();
        if (type.startsWith('intro')) return 'intro';
        if (type.startsWith('verse')) return 'verse';
        if (type.startsWith('pre')) return 'pre';
        if (type.startsWith('chorus')) return 'chorus';
        if (type.startsWith('bridge') || type.startsWith('breakdown')) return 'bridge';
        if (type.startsWith('outro')) return 'outro';
        return 'default';
    }

    function computeSectionVelocityMultiplier(section, layer, progress, isStrong) {
        const key = getSectionProfileKey(section);
        const profile = SECTION_VELOCITY_PROFILES[key] || SECTION_VELOCITY_PROFILES.default;
        const prog = Math.min(1, Math.max(0, progress || 0));

        let base = profile.base;
        let peak = profile.peak;

        if (layer === 'bass') {
            base -= 0.12;
            peak -= 0.1;
        } else if (layer === 'pad') {
            base -= 0.18;
            peak -= 0.15;
        } else if (layer === 'ornament') {
            base -= 0.2;
            peak -= 0.18;
        }

        let mul = base + (peak - base) * prog;
        if (isStrong && layer !== 'pad') mul += 0.04;
        if (layer === 'ornament') mul -= 0.04;
        return Math.max(0.35, Math.min(1.15, mul));
    }

    const HOOK_FORM_LIBRARY = {
        classic: [
            ['A', 'B', 'A', 'C'],
            ['A', 'A', 'B', 'A'],
            ['A', 'B', 'C', 'B']
        ],
        mantra: [
            ['A', 'A', 'A', 'B'],
            ['A', 'B', 'A', 'B'],
            ['A', 'B', 'B', 'C']
        ],
        wave: [
            ['A', 'C', 'B', 'C'],
            ['A', 'B', 'A', 'D'],
            ['A', 'C', 'A', 'B']
        ],
        callResponse: [
            ['A', 'B', 'A', 'B'],
            ['A', 'B', 'C', 'A'],
            ['A', 'B', 'A', 'C']
        ],
        surge: [
            ['A', 'B', 'C', 'D'],
            ['A', 'C', 'D', 'A'],
            ['A', 'B', 'D', 'B']
        ]
    };
    const ALL_HOOK_FORMS = Object.values(HOOK_FORM_LIBRARY).reduce((acc, group) => acc.concat(group), []);

    function buildHookFormSequence(barCount, profile) {
        if (barCount <= 1) return ['A'];
        const flavor = profile?.hookFormFlavor;
        const pools = (flavor && HOOK_FORM_LIBRARY[flavor]) ? HOOK_FORM_LIBRARY[flavor] : ALL_HOOK_FORMS;
        const preset = randomChoice(pools);
        const seq = [];
        for (let i = 0; i < barCount; i++) {
            seq.push(preset[i % preset.length]);
        }
        return seq;
    }

    const RHYTHM_BANKS = {
        minimal: [
            [4],
            [2, 2],
            [1.5, 2.5],
            [1, 3]
        ],
        lyric: [
            [1, 1, 1, 1],
            [1, 0.5, 0.5, 2],
            [0.5, 1.5, 0.5, 1.5],
            [0.5, 0.5, 1, 0.5, 1.5]
        ],
        syncopated: [
            [0.75, 0.25, 1, 0.5, 1.5],
            [0.5, 1.5, 0.5, 0.5, 1],
            [0.25, 0.75, 1, 1, 1],
            [0.5, 1, 0.5, 1, 1]
        ],
        busy: [
            [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1],
            [0.25, 0.25, 0.5, 0.5, 0.5, 0.5, 1, 0.5],
            [0.5, 0.5, 0.25, 0.25, 0.5, 0.5, 1],
            [0.25, 0.75, 0.5, 0.5, 0.25, 0.75, 1]
        ],
        swing: [
            [0.75, 0.25, 0.75, 0.25, 1, 1],
            [0.66, 0.34, 1, 0.66, 0.34, 1],
            [0.5, 0.5, 0.66, 0.34, 2],
            [0.75, 0.25, 0.5, 0.5, 0.75, 0.25, 1]
        ],
        mantra: [
            [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
            [1, 0.5, 0.5, 1, 0.5, 0.5],
            [0.5, 1, 0.5, 1, 0.5, 0.5],
            [0.5, 0.5, 0.5, 0.5, 1, 1]
        ]
    };

    const SONG_BLUEPRINT_LIBRARY = [
        {
            name: 'classic_pop',
            flavors: ['classic_ballad', 'neo_soul', 'anthemic'],
            sections: [
                { type: 'intro', base: 4, min: 2, max: 6, chords: 'verse' },
                { type: 'verse1', base: 8, min: 6, max: 12, chords: 'verse' },
                { type: 'pre1', base: 4, min: 3, max: 5, chords: 'chorus' },
                { type: 'chorus1', base: 8, min: 6, max: 12, chords: 'chorus' },
                { type: 'verse2', base: 8, min: 6, max: 12, chords: 'verse' },
                { type: 'pre2', base: 4, min: 3, max: 5, chords: 'chorus' },
                { type: 'chorus2', base: 8, min: 6, max: 14, chords: 'chorus' },
                { type: 'bridge', base: 6, min: 4, max: 8, chords: 'chorus' },
                { type: 'chorus3', base: 8, min: 6, max: 16, chords: 'chorus' },
                { type: 'outro', base: 4, min: 2, max: 6, chords: 'chorus' }
            ],
            options: { doubleFinalChorus: true }
        },
        {
            name: 'drop_first',
            flavors: ['edm_drop', 'trap_stack', 'anthemic'],
            sections: [
                { type: 'intro', base: 2, min: 0, max: 4, chords: 'chorus' },
                { type: 'chorus1', base: 8, min: 6, max: 12, chords: 'chorus' },
                { type: 'verse1', base: 8, min: 4, max: 10, chords: 'verse' },
                { type: 'pre1', base: 4, min: 2, max: 4, chords: 'chorus' },
                { type: 'chorus2', base: 8, min: 6, max: 12, chords: 'chorus' },
                { type: 'bridge', base: 4, min: 2, max: 6, chords: 'chorus' },
                { type: 'chorus3', base: 10, min: 8, max: 16, chords: 'chorus' },
                { type: 'outro', base: 2, min: 0, max: 4, chords: 'chorus' }
            ],
            options: { allowInstrumentDrop: true }
        },
        {
            name: 'verse_stack',
            flavors: ['rock_drive', 'classic_ballad', 'neo_soul'],
            sections: [
                { type: 'intro', base: 3, min: 2, max: 4, chords: 'verse' },
                { type: 'verse1', base: 8, min: 6, max: 12, chords: 'verse' },
                { type: 'verse2', base: 6, min: 4, max: 10, chords: 'verse' },
                { type: 'pre1', base: 4, min: 2, max: 4, chords: 'chorus' },
                { type: 'chorus1', base: 8, min: 6, max: 12, chords: 'chorus' },
                { type: 'bridge', base: 6, min: 3, max: 8, chords: 'chorus' },
                { type: 'chorus2', base: 8, min: 6, max: 12, chords: 'chorus' },
                { type: 'outro', base: 4, min: 2, max: 6, chords: 'verse' }
            ]
        },
        {
            name: 'ambient_story',
            flavors: ['ambient_wave', 'singer_songwriter'],
            sections: [
                { type: 'intro', base: 6, min: 4, max: 10, chords: 'verse' },
                { type: 'verse1', base: 8, min: 6, max: 12, chords: 'verse' },
                { type: 'pre1', base: 4, min: 2, max: 4, chords: 'chorus' },
                { type: 'chorus1', base: 6, min: 4, max: 10, chords: 'chorus' },
                { type: 'bridge', base: 6, min: 4, max: 10, chords: 'chorus' },
                { type: 'chorus2', base: 8, min: 6, max: 12, chords: 'chorus' },
                { type: 'outro', base: 6, min: 4, max: 10, chords: 'verse' }
            ],
            options: { longIntro: true, longOutro: true }
        },
        {
            name: 'hook_loop',
            flavors: ['trap_stack', 'edm_drop', 'alt_pop'],
            sections: [
                { type: 'intro', base: 1, min: 0, max: 2, chords: 'chorus' },
                { type: 'chorus1', base: 8, min: 6, max: 12, chords: 'chorus' },
                { type: 'verse1', base: 6, min: 4, max: 8, chords: 'verse' },
                { type: 'chorus2', base: 8, min: 6, max: 12, chords: 'chorus' },
                { type: 'bridge', base: 4, min: 2, max: 6, chords: 'chorus' },
                { type: 'chorus3', base: 12, min: 8, max: 16, chords: 'chorus' },
                { type: 'outro', base: 2, min: 1, max: 4, chords: 'chorus' }
            ],
            options: { loopedChorus: true }
        }
    ];

    const INTENT_PROFILES = [
        {
            name: 'piano_ballad',
            mood: 'warm',
            genre: 'ballad',
            grooveFlavor: 'pop',
            structureFlavor: 'classic_ballad',
            rhythmFlavor: 'straight',
            motifComplexity: 'sparse',
            motifDensity: { intro: 'sparse', verse: 'sparse', pre: 'medium', chorus: 'medium', bridge: 'sparse', outro: 'sparse' },
            hookContours: ['arch', 'fall'],
            hookFormFlavor: 'classic',
            tensionPlan: ['calm', 'build', 'lift', 'release'],
            motifOptions: {
                verseDensity: 'sparse',
                chorusDensity: 'medium',
                hookRhythmBias: 'lyric',
                avoidTonic: false,
                verseRestChance: 0.55
            },
            harmonyColor: { borrowIVm: true, addbVII: false, secDomChance: 0.35, modalShiftChance: 0.1 },
            ornamentBias: { density: 0.22, duration: 0.22 },
            instrumentPlan: { drums: 'late_entry', bass: 'after_intro', pads: 'always' },
            bassBehavior: 'pedal',
            drumBehavior: 'soft_backbeat',
            padBehavior: 'lush',
            variationPolicy: { hookOctaveChance: 0.15, verseDrones: true }
        },
        {
            name: 'edm_pluck',
            mood: 'bright',
            genre: 'edm',
            grooveFlavor: 'edm',
            structureFlavor: 'edm_drop',
            rhythmFlavor: 'four_on_floor',
            motifComplexity: 'busy',
            motifDensity: { intro: 'medium', verse: 'medium', pre: 'dense', chorus: 'dense', bridge: 'medium', outro: 'sparse' },
            hookContours: ['rise', 'surge', 'arch'],
            hookFormFlavor: 'surge',
            tensionPlan: ['build', 'lift', 'drive', 'release'],
            motifOptions: {
                verseDensity: 'medium',
                chorusDensity: 'dense',
                hookRhythmBias: 'anthem',
                avoidTonic: false,
                verseRestChance: 0.2
            },
            harmonyColor: { borrowIVm: false, addbVII: true, secDomChance: 0.65, addSus: true },
            ornamentBias: { density: 0.35, duration: 0.16 },
            instrumentPlan: { drums: 'full', bass: 'full', pads: 'chorus_only' },
            bassBehavior: 'drive',
            drumBehavior: 'four_on_floor',
            padBehavior: 'stabs',
            variationPolicy: { hookOctaveChance: 0.65, callResponseChance: 0.4 }
        },
        {
            name: 'rock_drive',
            mood: 'intense',
            genre: 'rock',
            grooveFlavor: 'rock',
            structureFlavor: 'rock_drive',
            rhythmFlavor: 'straight',
            motifComplexity: 'medium',
            motifDensity: { intro: 'sparse', verse: 'medium', pre: 'medium', chorus: 'dense', bridge: 'medium', outro: 'sparse' },
            hookContours: ['rise', 'surge', 'arch'],
            hookFormFlavor: 'callResponse',
            tensionPlan: ['build', 'lift', 'drive', 'release'],
            motifOptions: {
                verseDensity: 'medium',
                chorusDensity: 'dense',
                hookRhythmBias: 'anthem',
                avoidTonic: true,
                verseRestChance: 0.25
            },
            harmonyColor: { borrowIVm: false, addbVII: true, secDomChance: 0.6, addSus: true },
            ornamentBias: { density: 0.22, duration: 0.2 },
            instrumentPlan: { drums: 'full', bass: 'full', pads: 'sparingly' },
            bassBehavior: 'octave_drive',
            drumBehavior: 'arena',
            padBehavior: 'guitarish',
            variationPolicy: { hookOctaveChance: 0.35, verseDrones: false }
        },
        {
            name: 'ambient_minimal',
            mood: 'dream',
            genre: 'ambient',
            grooveFlavor: 'pop',
            structureFlavor: 'ambient_wave',
            rhythmFlavor: 'half_time',
            motifComplexity: 'minimal',
            motifDensity: { intro: 'minimal', verse: 'sparse', pre: 'sparse', chorus: 'medium', bridge: 'sparse', outro: 'minimal' },
            hookContours: ['wave', 'arch'],
            hookFormFlavor: 'wave',
            tensionPlan: ['calm', 'dream', 'lift', 'resolve'],
            motifOptions: {
                verseDensity: 'sparse',
                chorusDensity: 'medium',
                hookRhythmBias: 'flow',
                avoidTonic: true,
                verseRestChance: 0.45
            },
            harmonyColor: { borrowIVm: true, addbVII: false, secDomChance: 0.25, modern: true },
            ornamentBias: { density: 0.18, duration: 0.26 },
            instrumentPlan: { drums: 'bridge_only', bass: 'late_entry', pads: 'always' },
            bassBehavior: 'pedal',
            drumBehavior: 'minimal',
            padBehavior: 'evolving',
            variationPolicy: { hookOctaveChance: 0.1, sustainFirstVerse: true }
        },
        {
            name: 'neo_soul',
            mood: 'wistful',
            genre: 'neo_soul',
            grooveFlavor: 'pop',
            structureFlavor: 'neo_soul',
            rhythmFlavor: 'swing',
            motifComplexity: 'medium',
            motifDensity: { intro: 'sparse', verse: 'medium', pre: 'medium', chorus: 'dense', bridge: 'medium', outro: 'sparse' },
            hookContours: ['arch', 'wave'],
            hookFormFlavor: 'callResponse',
            tensionPlan: ['dream', 'lift', 'lift', 'resolve'],
            motifOptions: {
                verseDensity: 'medium',
                chorusDensity: 'dense',
                hookRhythmBias: 'flow',
                avoidTonic: true,
                verseRestChance: 0.35
            },
            harmonyColor: { borrowIVm: true, addbVII: true, secDomChance: 0.45, addSus: true },
            ornamentBias: { density: 0.3, duration: 0.22 },
            instrumentPlan: { drums: 'no_intro', bass: 'full', pads: 'always' },
            bassBehavior: 'walking',
            drumBehavior: 'shuffle',
            padBehavior: 'lush',
            variationPolicy: { hookOctaveChance: 0.25, callResponseChance: 0.5 }
        },
        {
            name: 'trap_pop',
            mood: 'moody',
            genre: 'trap',
            grooveFlavor: 'edm',
            structureFlavor: 'trap_stack',
            rhythmFlavor: 'half_time',
            motifComplexity: 'medium',
            motifDensity: { intro: 'minimal', verse: 'sparse', pre: 'medium', chorus: 'dense', bridge: 'medium', outro: 'sparse' },
            hookContours: ['rise', 'mantra'],
            hookFormFlavor: 'mantra',
            tensionPlan: ['build', 'lift', 'drive', 'release'],
            motifOptions: {
                verseDensity: 'sparse',
                chorusDensity: 'dense',
                hookRhythmBias: 'syncopated',
                avoidTonic: true,
                verseRestChance: 0.3
            },
            harmonyColor: { borrowIVm: true, addbVII: true, secDomChance: 0.4, modalShiftChance: 0.2 },
            ornamentBias: { density: 0.26, duration: 0.18 },
            instrumentPlan: { drums: 'chorus_only', bass: '808', pads: 'sparingly' },
            bassBehavior: '808_drops',
            drumBehavior: 'half_time',
            padBehavior: 'plucks',
            variationPolicy: { hookOctaveChance: 0.5, mantraChance: 0.6 }
        },
        {
            name: 'cinematic_anthem',
            mood: 'epic',
            genre: 'anthemic',
            grooveFlavor: 'pop',
            structureFlavor: 'anthemic',
            rhythmFlavor: 'double_time',
            motifComplexity: 'busy',
            motifDensity: { intro: 'medium', verse: 'medium', pre: 'dense', chorus: 'dense', bridge: 'dense', outro: 'medium' },
            hookContours: ['surge', 'rise', 'arch'],
            hookFormFlavor: 'surge',
            tensionPlan: ['build', 'lift', 'drive', 'sky'],
            motifOptions: {
                verseDensity: 'medium',
                chorusDensity: 'dense',
                hookRhythmBias: 'anthem',
                avoidTonic: false,
                verseRestChance: 0.2
            },
            harmonyColor: { borrowIVm: true, addbVII: true, secDomChance: 0.7, modalShiftChance: 0.25 },
            ornamentBias: { density: 0.34, duration: 0.2 },
            instrumentPlan: { drums: 'full', bass: 'full', pads: 'always' },
            bassBehavior: 'interval_jumps',
            drumBehavior: 'arena',
            padBehavior: 'stacked',
            variationPolicy: { hookOctaveChance: 0.7, callResponseChance: 0.45 }
        }
    ];

    function selectIntentProfile() {
        const intent = randomChoice(INTENT_PROFILES);
        return JSON.parse(JSON.stringify(intent));
    }

    function buildSongProfile(context = {}) {
        const preset = context.intent || selectIntentProfile();
        const profile = JSON.parse(JSON.stringify(preset));
        profile.userDensity = context.density || 'medium';
        profile.userRange = context.range || 'mid';
        profile.hookBars = Math.max(1, context.hookBars || 4);
        profile.totalBars = Math.max(8, context.totalBars || 64);
        profile.instrumentRules = buildInstrumentPlan(profile.instrumentPlan || {}, {
            bass: context.genBass,
            pads: context.genChords
        });
        profile.motifDensityMap = buildMotifDensityMap(profile, profile.userDensity);
        profile.structurePreset = chooseBlueprintForSong(profile);
        profile.structureOptions = (profile.structurePreset && profile.structurePreset.options) || {};
        return profile;
    }

    function chooseBlueprintForSong(profile) {
        const flavor = profile?.structureFlavor;
        const candidates = SONG_BLUEPRINT_LIBRARY.filter(bp => {
            if (!flavor || !bp.flavors || bp.flavors.length === 0) return true;
            return bp.flavors.includes(flavor);
        });
        const pool = candidates.length ? candidates : SONG_BLUEPRINT_LIBRARY;
        return JSON.parse(JSON.stringify(randomChoice(pool)));
    }

    function buildMotifDensityMap(profile, densitySetting) {
        const fallback = densitySetting || 'medium';
        const base = profile?.motifDensity || {};
        return {
            intro: base.intro || (fallback === 'dense' ? 'medium' : 'sparse'),
            verse: base.verse || fallback,
            pre: base.pre || fallback,
            chorus: base.chorus || 'dense',
            bridge: base.bridge || fallback,
            outro: base.outro || 'sparse',
            default: fallback
        };
    }

    function buildInstrumentPlan(plan = {}, overrides = {}) {
        const allowBass = overrides.bass !== false;
        const allowPads = overrides.pads !== false;
        return {
            drums: plan.drums || 'full',
            bass: allowBass ? (plan.bass || 'full') : 'none',
            pads: allowPads ? (plan.pads || 'sparingly') : 'none'
        };
    }

    function shouldPlayInstrumentInSection(profile, instrument, sectionType) {
        const rules = profile?.instrumentRules || {};
        const plan = rules[instrument];
        if (!plan || plan === 'full' || plan === 'always' || plan === '808') return true;
        if (plan === 'none') return false;
        const key = normalizeSectionKey(sectionType || '');
        switch (plan) {
            case 'late_entry':
            case 'after_intro':
                return key !== 'intro' && !sectionType?.startsWith('verse1');
            case 'no_intro':
                return key !== 'intro' && key !== 'outro';
            case 'chorus_only':
                return key.startsWith('chorus');
            case 'bridge_only':
                return key.startsWith('bridge');
            case 'sparingly':
                return key === 'verse' || key === 'pre' || key === 'bridge';
            case 'chorus_focus':
                return key === 'chorus' || key === 'pre';
            case 'late_peak':
                return key === 'bridge' || key === 'chorus' || key === 'outro';
            default:
                return true;
        }
    }

    function densityToRhythmBank(density, fallback = 'lyric') {
        switch (density) {
            case 'minimal':
            case 'sparse':
                return 'minimal';
            case 'medium':
                return 'lyric';
            case 'dense':
                return 'busy';
            case 'hook':
                return 'busy';
            default:
                return fallback;
        }
    }

    function pickRhythmBankForSection(profile, sectionType, density, { isHook = false } = {}) {
        const key = normalizeSectionKey(sectionType || '');
        const map = profile?.motifDensityMap || {};
        const targetDensity = density || map[key] || map.default || profile?.motifComplexity || 'medium';
        const rhythmFlavor = profile?.rhythmFlavor;

        if (isHook && profile?.variationPolicy?.mantraChance && Math.random() < profile.variationPolicy.mantraChance) {
            return 'mantra';
        }

        if (rhythmFlavor === 'swing' && (key === 'verse' || key === 'pre' || Math.random() < 0.5)) {
            return 'swing';
        }
        if (rhythmFlavor === 'half_time' && key === 'verse') {
            return targetDensity === 'dense' ? 'syncopated' : 'minimal';
        }
        if (rhythmFlavor === 'double_time' && key.startsWith('chorus')) {
            return 'busy';
        }
        if (rhythmFlavor === 'four_on_floor' && key.startsWith('chorus')) {
            return targetDensity === 'dense' ? 'busy' : 'syncopated';
        }
        return densityToRhythmBank(targetDensity, 'lyric');
    }

    function resolveContourForSection(profile, sectionType) {
        if (sectionType.startsWith('chorus') && profile?.hookContours?.length) {
            return randomChoice(profile.hookContours);
        }
        if (sectionType.startsWith('verse')) {
            return profile?.variationPolicy?.verseDrones ? 'hold' : 'rise';
        }
        if (sectionType.startsWith('bridge')) return 'wave';
        if (sectionType.startsWith('pre')) return 'lift';
        return 'arch';
    }

    function applyIntentToStructure(structure, intent) {
        if (!intent || !intent.tensionPlan || !intent.tensionPlan.length) return;
        const plan = intent.tensionPlan;
        structure.forEach((sec, idx) => {
            sec.intentPhase = plan[idx % plan.length];
        });
    }

    function chooseStartPitch(key, rangeInfo, isChorusMain, isSub) {
        const rootMidi = 60 + key.rootPc;
        const center = isChorusMain ? rootMidi + 2 : rootMidi;
        const minMidi = rangeInfo.minMidi;
        const maxMidi = rangeInfo.maxMidi;
        const versePool = [key.scalePcs[0], key.scalePcs[2], key.scalePcs[4], key.scalePcs[5]];
        const chorusPool = [key.scalePcs[4], key.scalePcs[0], key.scalePcs[2], key.scalePcs[5]];
        const candidatePcs = isChorusMain ? chorusPool : versePool;
        if (!isChorusMain && Math.random() < 0.35) {
            candidatePcs.push(key.scalePcs[1]); // add 2nd for lift-in
        }
        const octaveStart = isSub ? 3 : 2;
        const candidates = [];
        candidatePcs.forEach(pc => {
            for (let o = octaveStart; o <= 7; o++) {
                const m = o * 12 + pc;
                if (m >= minMidi && m <= maxMidi) {
                    const weight = Math.max(0.1, 1 - Math.abs(m - center) / 12);
                    candidates.push({ midi: m, weight });
                }
            }
        });
        if (!candidates.length) return clampMidiToRange(center, rangeInfo);

        if (!isChorusMain && Math.random() < 0.3) {
            candidates.forEach(c => {
                if (c.midi < center) c.weight *= 1.2;
            });
        }

        const totalWeight = candidates.reduce((s, c) => s + c.weight, 0);
        let pick = Math.random() * totalWeight;
        for (const cand of candidates) {
            pick -= cand.weight;
            if (pick <= 0) return cand.midi;
        }
        return candidates[0].midi;
    }

    // === Penalize overly repetitive AB/AAAA melodic patterns ===
    function computePatternPenalty(history, candidateMidi) {
        const maxLen = 4;
        if (!history || history.length < 3) return 0;
        const seq = history.slice(-16).concat(candidateMidi);
        let penalty = 0;

        for (let len = 2; len <= maxLen; len++) {
            if (seq.length < len * 2) continue;
            const lastStart = seq.length - len;
            const lastPattern = seq.slice(lastStart);
            let repeatCount = 0;

            for (let i = 0; i <= seq.length - len * 2; i++) {
                let ok = true;
                for (let j = 0; j < len; j++) {
                    if (seq[i + j] !== lastPattern[j]) {
                        ok = false;
                        break;
                    }
                }
                if (ok) repeatCount++;
            }

            if (repeatCount > 0) {
                const weight = (len === 2) ? 2.0 : 0.8;
                penalty -= repeatCount * len * weight;
            }
        }
        return penalty;
    }

    // === Score each melodic candidate based on context and style ===
    function evaluateMelodicCandidate({
        midi,
        prevMidi,
        interval,
        prevInterval,
        key,
        rangeInfo,
        isStrong,
        isChorusMain,
        isSub,
        history,
        melodyStyle,
        contourPref,
        intent
    }) {
        if (prevMidi == null) return 100;
        let score = 0;
        const dist = Math.abs(interval);
        const dir = Math.sign(interval);

        // 1) basic interval preference
        if (dist <= 1) {
            score += isChorusMain ? 3 : 6; // allow pedal tones but less dominant in hooks
        } else if (dist <= 2) {
            score += isChorusMain ? 7 : 9; // encourage whole-step moves
        } else if (dist <= 4) {
            score += isChorusMain ? 6 : 4; // reward thirds in hooks more
        } else if (dist <= 7) {
            score += isChorusMain ? 1 : -1; // chorus can leap occasionally
        } else {
            score -= 8;
        }

        if (isChorusMain && dist >= 4 && dist <= 7 && Math.random() < 0.25) {
            score += 3; // bias toward at least one leap in chorus bars
        }

        // 2) avoid consecutive large leaps in the same direction
        if (prevInterval != null &&
            Math.sign(prevInterval) === Math.sign(interval) &&
            Math.abs(prevInterval) >= 5 &&
            dist >= 5) {
            score -= 10;
        }

        // 3) prevent long stretches of the exact same pitch
        if (prevMidi != null && midi === prevMidi) {
            // Allow quick hook repeats but penalize droning on the same pitch.
            score -= isStrong ? 1.0 : 2.5;
        }
        if (history && history.length >= 2) {
            const h1 = history[history.length - 1];
            const h2 = history[history.length - 2];
            if (midi === h1 && midi === h2) {
                // Strongly penalize three identical notes in a row.
                score -= 6;
            }
        }

        // 4) keep the melody centered inside its target range
        const center = rangeInfo.centerMidi;
        const dCenter = Math.abs(midi - center);
        score -= dCenter / 4;
        if (midi > center + 7) score -= 8;
        if (midi < center - 9) score -= 4;

        // 5) give chorus mains a slight boost when they sit above center
        if (isChorusMain && midi > center) {
            score += 2;
        }

        // 6) style bias
        if (!melodyStyle) melodyStyle = 'smooth';
        if (melodyStyle === 'smooth') {
            if (dist > 3) score -= (dist - 3) * 1.5;
        } else if (melodyStyle === 'hooky') {
            if (dist === 2 || dist === 3) score += 3;
            const pc = midi % 12;
            if (key.scalePcs.includes(pc)) score += 1;
        } else if (melodyStyle === 'leapy') {
            if (dist >= 4 && dist <= 7) score += 2.5;
        }

        if (isChorusMain && contourPref) {
            if (contourPref === 'rise' && dir > 0) score += 2;
            if (contourPref === 'fall' && dir < 0) score += 2;
            if (contourPref === 'hold' && dist <= 1) score += 2;
            if (contourPref === 'zigzag' && dist >= 2) score += 1.5;
        }

        if (intent && intent.motifOptions && intent.motifOptions.avoidTonic && isChorusMain) {
            if ((midi % 12) === key.rootPc && !isStrong) score -= 3;
        }
        if (intent && intent.mood === 'wistful' && !isChorusMain && dir < 0) {
            score += 0.7;
        }
        if (intent && intent.mood === 'intense' && isChorusMain && dist >= 4) {
            score += 1.2;
        }

        // 7) discourage pasted patterns via computePatternPenalty
        if (history && history.length >= 3) {
            score += computePatternPenalty(history, midi);
        }

        // 8) give weaker-beat verse notes a subtle bonus
        if (!isStrong && !isChorusMain) {
            score += 0.5;
        }

        return score;
    }

    // === Choose the next pitch using history + style cues ===
    function chooseNextPitch(prevMidi, key, rangeInfo, isStrong, isChorusMain, isSub, prevInterval, history, melodyStyle, intent) {
        if (prevMidi == null) {
            return chooseStartPitch(key, rangeInfo, isChorusMain, isSub);
        }

        // Build interval pools for steps, small jumps, and optional leaps
        const smallSteps    = [0, 1, -1, 2, -2];
        const smallJumps    = [3, -3, 4, -4];
        const leapIntervals = [5, -5, 7, -7];

        let intervals = smallSteps.concat(smallJumps);

        if (isChorusMain && Math.random() < 0.85) {
            intervals = intervals.concat(leapIntervals, [6, -6]);
        } else if (!isChorusMain && Math.random() < 0.3) {
            intervals = intervals.concat([5, -5]);
        }

        if (melodyStyle === 'smooth') {
            intervals = intervals.filter(iv => Math.abs(iv) <= 4);
        } else if (melodyStyle === 'leapy') {
            intervals = intervals.concat([7, -7]);
        }

        if (prevInterval != null && Math.abs(prevInterval) >= 5) {
            const prevDir = Math.sign(prevInterval);
            intervals = intervals.filter(iv => {
                const dir = Math.sign(iv);
                if (dir === prevDir && Math.abs(iv) >= 5) return false;
                return true;
            });
        }

        const candidates = [];
        const localHistory = (history || []).slice(-16);

        const contourPref = (isChorusMain && melodyStyle !== 'smooth')
            ? randomChoice(['rise', 'fall', 'hold', 'zigzag'])
            : 'mixed';

        for (const iv of intervals) {
            let midi = prevMidi + iv;
            midi = clampMidiToRange(midi, rangeInfo);
            midi = quantizeToScale(midi, key);

            const score = evaluateMelodicCandidate({
                midi,
                prevMidi,
                interval: iv,
                prevInterval,
                key,
                rangeInfo,
                isStrong,
                isChorusMain,
                isSub,
                history: localHistory,
                melodyStyle,
                contourPref,
                intent
            });

            candidates.push({ midi, score });
        }

        if (!candidates.length) {
            return clampMidiToRange(prevMidi, rangeInfo);
        }

        candidates.sort((a, b) => b.score - a.score);
        return candidates[0].midi;
    }

    function smoothMotifMelodicLeaps(motifNotes, key, rangeInfo, isChorusMain) {
        if (!motifNotes || motifNotes.length < 2) return;
        motifNotes.sort((a, b) => a.startOffset - b.startOffset);
        const maxLeap = isChorusMain ? 9 : 12;

        for (let i = 1; i < motifNotes.length; i++) {
            const prev = motifNotes[i - 1];
            const curr = motifNotes[i];
            let interval = curr.midi - prev.midi;
            let size = Math.abs(interval);
            if (size < 7) continue;
            const dir = interval >= 0 ? 1 : -1;

            if (size > maxLeap) {
                const target = prev.midi + dir * maxLeap;
                curr.midi = clampMidiToRange(quantizeToScale(target, key), rangeInfo);
                interval = curr.midi - prev.midi;
                size = Math.abs(interval);
            }

            if (size < 7) continue;

            if (i >= 2) {
                const pre = motifNotes[i - 2];
                const step = 2;
                const targetPrev = curr.midi - dir * step;
                prev.midi = clampMidiToRange(quantizeToScale(targetPrev, key), rangeInfo);

                const targetPre = prev.midi - dir * step;
                pre.midi = clampMidiToRange(quantizeToScale(targetPre, key), rangeInfo);
            } else {
                const step = 2;
                const targetPrev = curr.midi - dir * step;
                prev.midi = clampMidiToRange(quantizeToScale(targetPrev, key), rangeInfo);
            }

            if (i + 1 < motifNotes.length) {
                const next = motifNotes[i + 1];
                const stepChoices = [1, 2];
                const step = randomChoice(stepChoices);
                const sign = Math.random() < 0.5 ? 1 : -1;
                const targetNext = curr.midi + sign * step;
                next.midi = clampMidiToRange(quantizeToScale(targetNext, key), rangeInfo);
            }
        }
    }

    function imposeMotifRepetition(notes, bars, rangeInfo) {
        const beatsPerBar = 4;
        if (bars < 2 || !notes.length) return;
        const firstBarNotes = notes.filter(n => n.startOffset < beatsPerBar);
        if (firstBarNotes.length === 0) return;
        if (Math.random() < 0.35) return; // occasionally skip strict repetition
        const anchor = firstBarNotes.reduce((a, b) => a.startOffset <= b.startOffset ? a : b);

        const candidateBars = [];
        for (let bar = 1; bar < bars; bar++) candidateBars.push(bar);
        candidateBars.sort(() => Math.random() - 0.5);
        const limit = Math.max(1, Math.round(candidateBars.length * 0.4));
        const selected = new Set(candidateBars.slice(0, limit));

        for (let bar = 1; bar < bars; bar++) {
            if (!selected.has(bar)) continue;
            const barStart = bar * beatsPerBar;
            const target = notes.find(n => n.startOffset >= barStart && n.startOffset < barStart + 0.5);
            if (!target) continue;
            if (Math.random() < 0.25) continue;
            let transpose = 0;
            if (bar === bars - 1 && Math.random() < 0.7) {
                transpose = Math.random() < 0.5 ? 2 : -2;
            }
            target.midi = clampMidiToRange(anchor.midi + transpose, rangeInfo);
        }
    }

    // === Build a motif bar while honoring history & style ===
    function buildMotifBar({ key, rangeInfo, durations, isChorusMain, isSub, melodyStyle, intent }) {
        const notesInBar = [];
        let t = 0;
        let prevMidi = null;
        let prevInterval = null;
        const pitchHistory = [];

        for (let i = 0; i < durations.length; i++) {
            const dur = durations[i];
            const strong = (Math.abs(t - 0) < 1e-6) || (Math.abs(t - 2) < 1e-6);
            let midi;
            if (prevMidi == null) {
                midi = chooseStartPitch(key, rangeInfo, isChorusMain, isSub);
            } else {
                midi = chooseNextPitch(
                    prevMidi,
                    key,
                    rangeInfo,
                    strong,
                    isChorusMain,
                    isSub,
                    prevInterval,
                    pitchHistory,
                    melodyStyle,
                    intent
                );
            }
            midi = clampMidiToRange(quantizeToScale(midi, key), rangeInfo);

            const baseVel = isChorusMain
                ? randomFloat(0.84, 0.92)
                : (isSub ? randomFloat(0.7, 0.8) : randomFloat(0.74, 0.85));
            const accent = strong ? randomFloat(0.08, 0.14) : randomFloat(-0.02, 0.03);
            const v = Math.max(0.4, Math.min(1, baseVel + accent));

            notesInBar.push({ midi, pos: t, duration: dur, velocity: v });
            if (prevMidi != null) prevInterval = midi - prevMidi;
            prevMidi = midi;
            pitchHistory.push(midi);
            t += dur;
        }
        return notesInBar;
    }

    function varyMotifBar(barNotes, { key, rangeInfo, strength }) {
        const result = barNotes.map(n => ({ ...n }));
        const count = result.length;
        if (!count) return result;

        const changeCount = strength === 'medium'
            ? Math.max(1, Math.round(count * 0.4))
            : 1;

        const indices = new Set();
        indices.add(count - 1);
        for (let i = 0; i < count - 1 && indices.size < changeCount; i++) {
            if (Math.random() < 0.5) indices.add(i);
        }

        indices.forEach(idx => {
            const n = result[idx];
            const stepOptions = strength === 'medium' ? [2, -2, 3, -3] : [2, -2];
            const step = randomChoice(stepOptions);
            let midiNew = n.midi + step;
            midiNew = clampMidiToRange(quantizeToScale(midiNew, key), rangeInfo);
            n.midi = midiNew;
        });

        return result;
    }

    function sequenceMotifBar(barNotes, { key, rangeInfo, direction }) {
        const step = direction || (Math.random() < 0.5 ? 2 : -2);
        return barNotes.map(n => {
            let m = n.midi + step;
            m = clampMidiToRange(quantizeToScale(m, key), rangeInfo);
            return { ...n, midi: m };
        });
    }

    function mutateMotifInstance(motif, { key, rangeInfo, strength }) {
        if (!motif || motif.length === 0) return motif;
        const clone = motif.map(n => ({ ...n }));
        const ratioMap = { strong: 0.45, medium: 0.3, light: 0.18 };
        const ratio = ratioMap[strength] || 0.25;
        const changeCount = Math.max(1, Math.round(clone.length * ratio));
        let stepPool;
        if (strength === 'strong') stepPool = [1, 2, 3, -1, -2, -3, 4, -4];
        else if (strength === 'light') stepPool = [1, -1, 2, -2];
        else stepPool = [1, 2, -1, -2, 3, -3];

        for (let i = 0; i < changeCount; i++) {
            const idx = Math.floor(Math.random() * clone.length);
            const note = clone[idx];
            if (!note) continue;
            const step = randomChoice(stepPool);
            note.midi = clampMidiToRange(quantizeToScale(note.midi + step, key), rangeInfo);
        }
        return clone;
    }

    function cloneMotifNotes(motif) {
        if (!motif) return [];
        return motif.map(n => ({ ...n }));
    }

    function buildMotifVariantSet(baseMotif, { key, rangeInfo, extraGenerators = [] }) {
        const variants = [];
        if (baseMotif && baseMotif.length) {
            variants.push(cloneMotifNotes(baseMotif));
            variants.push(mutateMotifInstance(baseMotif, { key, rangeInfo, strength: 'light' }));
            if (Math.random() < 0.7) {
                variants.push(mutateMotifInstance(baseMotif, { key, rangeInfo, strength: 'medium' }));
            }
        }
        extraGenerators.forEach(gen => {
            if (typeof gen !== 'function') return;
            const generated = gen();
            if (generated && generated.length) {
                variants.push(generated);
            }
        });
        return variants.filter(v => v && v.length);
    }

    function forceMotifLeap(motif, { key, rangeInfo, minInterval = 4 }) {
        const clone = motif.map(n => ({ ...n }));
        if (!clone.length) return clone;
        const targetIdx = Math.floor(Math.random() * clone.length);
        const note = clone[targetIdx];
        if (!note) return clone;
        const dir = Math.random() < 0.5 ? 1 : -1;
        const interval = dir * randomChoice([minInterval, minInterval + 1, minInterval + 2]);
        note.midi = clampMidiToRange(quantizeToScale(note.midi + interval, key), rangeInfo);
        return clone;
    }

    function enforcePedalTone(motif, key) {
        const clone = motif.map(n => ({ ...n }));
        if (!clone.length) return clone;
        const rootMidi = 60 + key.rootPc;
        const pedalMidi = quantizeToScale(rootMidi, key);
        for (let i = 0; i < clone.length; i += 2) {
            clone[i].midi = pedalMidi;
        }
        return clone;
    }

    function shiftMotifPitch(motif, key, rangeInfo, steps) {
        const clone = motif.map(n => ({ ...n }));
        clone.forEach(note => {
            note.midi = clampMidiToRange(quantizeToScale(note.midi + steps, key), rangeInfo);
        });
        return clone;
    }

    function reshapeMotifRhythm(motif, mode) {
        const clone = motif.map(n => ({ ...n }));
        if (!clone.length) return clone;
        const scale = mode === 'stretch' ? 1.2 : 0.85;
        clone.forEach(note => {
            note.duration = Math.max(0.25, Math.min(2, note.duration * scale));
        });
        let cursor = clone[0].startOffset || 0;
        clone.forEach(note => {
            note.startOffset = cursor;
            cursor += note.duration;
        });
        return clone;
    }

    function applyHookShapeVariation(motif, { key, rangeInfo, mode, strength = 'light' }) {
        if (!motif || !motif.length) return motif;
        let result = motif.map(n => ({ ...n }));
        if (mode === 'pitchShift' || mode === 'both') {
            const steps = randomChoice([2, 4, -2, -4]);
            result = shiftMotifPitch(result, key, rangeInfo, steps);
        }
        if (mode === 'rhythmShift' || mode === 'both') {
            const reshapeMode = randomChoice(['stretch', 'shrink']);
            result = reshapeMotifRhythm(result, reshapeMode);
        }
        if (mode === 'none') {
            result = mutateMotifInstance(result, { key, rangeInfo, strength });
        }
        return result;
    }

    function alignNoteToTargets(note, pcs, key, rangeInfo) {
        if (!pcs || pcs.length === 0) return note.midi;
        return closestPitchToPcSet(note.midi, pcs, rangeInfo || getRangeInfo(key, 'mid'));
    }

    function shapeChorusHookMotif(motif, key, rangeInfo, intent) {
        if (!motif || !motif.length) return motif;
        const avoidTonic = intent && intent.motifOptions && intent.motifOptions.avoidTonic;
        const strongPcs = avoidTonic ? [(key.rootPc + 7) % 12] : [key.rootPc, (key.rootPc + 7) % 12];
        const colorPcs = [(key.rootPc + 2) % 12, (key.rootPc + 4) % 12, (key.rootPc + 11) % 12];
        const apexThreshold = (rangeInfo ? rangeInfo.centerMidi : 60 + key.rootPc) + 5;
        let hasApex = false;
        const shaped = motif.map(n => {
            const clone = { ...n };
            const beat = (clone.startOffset || 0) % 4;
            if (Math.abs(beat - 0) < 0.2 || Math.abs(beat - 2) < 0.2) {
                clone.midi = alignNoteToTargets(clone, strongPcs, key, rangeInfo);
            } else {
                clone.midi = alignNoteToTargets(clone, colorPcs, key, rangeInfo);
            }
            if (clone.midi >= apexThreshold) hasApex = true;
            return clone;
        });
        if (!hasApex) {
            let targetIndex = 0;
            let maxDuration = 0;
            shaped.forEach((n, idx) => {
                if (n.duration > maxDuration) { maxDuration = n.duration; targetIndex = idx; }
            });
            const apexNote = shaped[targetIndex];
            if (apexNote) {
                apexNote.midi = clampMidiToRange(
                    quantizeToScale(apexNote.midi + 4, key),
                    rangeInfo || getRangeInfo(key, 'mid')
                );
            }
        }
        return shaped;
    }

    function shapeVerseMotif(motif, key, rangeInfo, intent) {
        if (!motif || !motif.length) return motif;
        const rootTones = [key.rootPc, (key.rootPc + 3) % 12, (key.rootPc + 5) % 12];
        const restChance = intent && intent.motifOptions && intent.motifOptions.verseRestChance != null
            ? intent.motifOptions.verseRestChance
            : 0.3;
        return motif.map(n => {
            const clone = { ...n };
            const beat = (clone.startOffset || 0) % 4;
            if (Math.abs(beat - 0) < 0.15) {
                clone.midi = alignNoteToTargets(clone, rootTones, key, rangeInfo);
            } else if (Math.random() < restChance) {
                clone.midi = clampMidiToRange(
                    quantizeToScale(clone.midi - 2, key),
                    rangeInfo || getRangeInfo(key, 'mid')
                );
            }
            return clone;
        });
    }

    function closestPitchToPcSet(currentMidi, pcs, rangeInfo) {
        let best = currentMidi, bestDist = 1e9;
        pcs.forEach(pc => {
            for (let o = -2; o <= 2; o++) {
                const cand = (Math.floor(currentMidi / 12) + o) * 12 + pc;
                if (rangeInfo && (cand < rangeInfo.minMidi || cand > rangeInfo.maxMidi)) continue;
                const d = Math.abs(cand - currentMidi);
                if (d < bestDist) { bestDist = d; best = cand; }
            }
        });
        return best;
    }

    function makeCadentialMotifBar(barNotes, { key, rangeInfo }) {
        const result = barNotes.map(n => ({ ...n }));
        if (!result.length) return result;
        const lastIdx = result.length - 1;
        const prev = result[lastIdx - 1] || result[lastIdx];
        const targetPcs = [key.rootPc];
        const last = result[lastIdx];
        last.midi = closestPitchToPcSet(prev ? prev.midi : last.midi, targetPcs, rangeInfo);
        return result;
    }

    // === Structured auto-compose pipeline building blocks ===

    const SONG_BLUEPRINT = [
        { type: 'intro', base: 4, min: 2, max: 6, chords: 'verse' },
        { type: 'verse1', base: 8, min: 6, max: 12, chords: 'verse' },
        { type: 'pre1', base: 4, min: 3, max: 5, chords: 'chorus' },
        { type: 'chorus1', base: 8, min: 6, max: 12, chords: 'chorus' },
        { type: 'verse2', base: 8, min: 6, max: 12, chords: 'verse' },
        { type: 'pre2', base: 4, min: 3, max: 5, chords: 'chorus' },
        { type: 'chorus2', base: 8, min: 6, max: 12, chords: 'chorus' },
        { type: 'bridge', base: 6, min: 4, max: 8, chords: 'chorus' },
        { type: 'chorus3', base: 8, min: 6, max: 12, chords: 'chorus' },
        { type: 'outro', base: 4, min: 2, max: 6, chords: 'chorus' }
    ];

    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    const PART_VELOCITY_TARGETS = {
        melody: {
            intro: [0.5, 0.64],
            verse: [0.6, 0.8],
            pre: [0.68, 0.88],
            chorus: [0.82, 1.0],
            bridge: [0.7, 0.9],
            outro: [0.48, 0.65],
            default: [0.6, 0.82]
        },
        ornament: {
            intro: [0.32, 0.4],
            verse: [0.35, 0.48],
            pre: [0.4, 0.52],
            chorus: [0.45, 0.56],
            bridge: [0.4, 0.5],
            outro: [0.3, 0.42],
            default: [0.35, 0.5]
        },
        bass: {
            intro: [0.25, 0.38],
            verse: [0.3, 0.45],
            pre: [0.35, 0.5],
            chorus: [0.4, 0.55],
            bridge: [0.35, 0.5],
            outro: [0.25, 0.38],
            default: [0.32, 0.5]
        },
        pad: {
            intro: [0.35, 0.5],
            verse: [0.4, 0.55],
            pre: [0.45, 0.6],
            chorus: [0.52, 0.66],
            bridge: [0.45, 0.6],
            outro: [0.35, 0.5],
            default: [0.4, 0.58]
        },
        drum: {
            intro: [0.4, 0.6],
            verse: [0.45, 0.65],
            pre: [0.5, 0.72],
            chorus: [0.6, 0.85],
            bridge: [0.55, 0.75],
            outro: [0.4, 0.6],
            default: [0.5, 0.7]
        },
        drum_fx: {
            chorus: [0.75, 1],
            default: [0.65, 0.9]
        },
        default: {
            default: [0.5, 0.75]
        }
    };

    function getPartCategory(part) {
        const name = (part || '').toLowerCase();
        if (name.includes('bass')) return 'bass';
        if (name.includes('pad') || name.includes('chord')) return 'pad';
        if (name.includes('drum_fx')) return 'drum_fx';
        if (name.includes('drum')) return 'drum';
        if (name.includes('orn') || name.includes('pickup') || name.includes('transition')) return 'ornament';
        if (name.includes('hook') || name.includes('melody')) return 'melody';
        return 'default';
    }

    function normalizeAutoNoteDynamics(notes, structure, profile) {
        if (!Array.isArray(notes)) return notes || [];
        notes.forEach(note => {
            if (!note || !note.part || !note.part.startsWith('auto_')) return;
            const section = structure ? getSectionForBeat(structure, note.start) : null;
            const secKey = getSectionProfileKey(section);
            const partCat = getPartCategory(note.part);
            const partProfile = PART_VELOCITY_TARGETS[partCat] || PART_VELOCITY_TARGETS.default;
            const range = partProfile[secKey] || partProfile.default;
            if (!range) return;
            const [minTarget, maxTarget] = range;
            const sectionBeats = section ? Math.max(1, section.length * 4) : 4;
            const progress = section
                ? Math.min(1, Math.max(0, (note.start - section.startBar * 4) / sectionBeats))
                : 0;
            const target = minTarget + (maxTarget - minTarget) * progress;
            const blend =
                partCat === 'drum' ? 0.35 :
                partCat === 'bass' ? 0.45 :
                partCat === 'pad' ? 0.5 :
                partCat === 'ornament' ? 0.55 :
                0.65;
            const baseVelocity = note.velocity != null ? note.velocity : target;
            const contrastMul =
                profile?.motifComplexity === 'dense' ? 1.05 :
                    profile?.motifComplexity === 'sparse' ? 0.92 : 1;
            const newVelocity = (baseVelocity * (1 - blend) + target * blend) * contrastMul;
            note.velocity = clamp(
                newVelocity,
                Math.max(0.15, minTarget - 0.05),
                Math.min(1, maxTarget + 0.08)
            );
        });
        return notes;
    }

    function analyzeKeyAndChords({ key, verseChords, chorusChords }) {
        const fallback = makeChord(key.rootPc, key.mode === 'minor' ? 'min' : 'maj');
        const verse = (verseChords && verseChords.length)
            ? verseChords.slice()
            : (chorusChords && chorusChords.length ? chorusChords.slice() : [fallback]);
        const chorus = (chorusChords && chorusChords.length) ? chorusChords.slice() : verse.slice();
        const sectionRanges = {
            intro: getRangeInfo(key, 'low'),
            verse: getRangeInfo(key, 'mid'),
            pre: getRangeInfo(key, 'mid'),
            chorus: getRangeInfo(key, 'high'),
            bridge: getRangeInfo(key, 'mid'),
            outro: getRangeInfo(key, 'mid')
        };
        return {
            key,
            verseChords: verse,
            chorusChords: chorus,
            sectionRanges
        };
    }

    function buildSongStructurePlan(totalBars, hookBars, profile) {
        const hookMin = Math.max(4, Math.min(16, hookBars * 2 || 8));
        const preset = profile?.structurePreset;
        const sourceSections = (preset && Array.isArray(preset.sections) && preset.sections.length)
            ? preset.sections
            : SONG_BLUEPRINT;
        const opts = profile?.structureOptions || {};

        const blueprint = sourceSections.map(seg => {
            const base = seg.base || seg.min || 4;
            const min = seg.min != null ? seg.min : Math.max(1, Math.floor(base * 0.6));
            const max = seg.max != null ? seg.max : Math.max(min, Math.ceil(base * 1.5));
            const copy = { ...seg, base, min, max };
            if (seg.type.startsWith('chorus')) {
                copy.base = Math.max(copy.base, hookMin);
                copy.min = Math.max(copy.min, hookMin);
            }
            if (opts.longIntro && seg.type === 'intro') {
                copy.base = Math.max(copy.base, 4);
                copy.min = Math.max(copy.min, 4);
            }
            if (opts.longOutro && seg.type === 'outro') {
                copy.base = Math.max(copy.base, 4);
                copy.min = Math.max(copy.min, 4);
            }
            return copy;
        });

        const totalBase = blueprint.reduce((sum, seg) => sum + seg.base, 0);
        const scale = Math.max(0.35, totalBars / Math.max(1, totalBase));
        const structure = [];
        let cursor = 0;

        for (const seg of blueprint) {
            if (cursor >= totalBars) break;
            let length = Math.max(seg.min, Math.round(seg.base * scale));
            if (seg.max) length = Math.min(seg.max, length);
            if (opts.loopedChorus && seg.type.startsWith('chorus') && Math.random() < 0.35) {
                length += Math.round(Math.max(2, hookMin / 2));
            }
            if (cursor + length > totalBars) {
                length = totalBars - cursor;
            }
            if (length <= 0) continue;
            structure.push({ type: seg.type, chords: seg.chords, startBar: cursor, length });
            cursor += length;
        }

        if (cursor < totalBars) {
            const length = totalBars - cursor;
            structure.push({
                type: structure.some(sec => sec.type.startsWith('chorus')) ? 'chorus_final' : 'chorus1',
                chords: 'chorus',
                startBar: cursor,
                length
            });
            cursor += length;
        }

        if (opts.doubleFinalChorus && structure.length) {
            const last = structure[structure.length - 1];
            if (last && last.type.startsWith('chorus')) {
                const extraLen = Math.min(last.length, Math.max(hookMin, 4));
                const newStart = last.startBar + last.length;
                if (newStart < totalBars) {
                    const len = Math.min(extraLen, Math.max(0, totalBars - newStart));
                    if (len > 0) {
                        structure.push({
                            type: `${last.type}_repr`,
                            chords: 'chorus',
                            startBar: newStart,
                            length: len
                        });
                    }
                }
            }
        }

        if (!structure.some(sec => sec.type.startsWith('chorus'))) {
            const last = structure[structure.length - 1];
            if (last) {
                last.type = 'chorus1';
                last.chords = 'chorus';
            }
        }
        if (!structure.some(sec => sec.type.startsWith('verse'))) {
            const candidate = structure.find(sec => sec.type !== 'intro');
            if (candidate) {
                candidate.type = 'verse1';
                candidate.chords = 'verse';
            }
        }
        return structure;
    }

    function normalizeSectionKey(sectionType) {
        if (!sectionType) return '';
        if (sectionType.startsWith('verse')) return 'verse';
        if (sectionType.startsWith('chorus')) return 'chorus';
        if (sectionType.startsWith('pre')) return 'pre';
        return sectionType;
    }

    function getSectionForBar(bar, structure) {
        for (const s of structure) {
            if (bar >= s.startBar && bar < s.startBar + s.length) return s;
        }
        return structure[structure.length - 1];
    }

    function getSectionForBeat(structure, beat) {
        const bar = Math.floor(beat / 4);
        return getSectionForBar(bar, structure);
    }

    function getChordAtBar(bar, structure, verseChords, chorusChords) {
        const sec = getSectionForBar(bar, structure);
        let chords;
        if (sec.chords === 'chorus') chords = chorusChords.length ? chorusChords : verseChords;
        else chords = verseChords.length ? verseChords : chorusChords;
        if (!chords || chords.length === 0) return null;
        const localIndex = bar - sec.startBar;
        return chords[(localIndex % chords.length + chords.length) % chords.length];
    }

    function pickCadentialPitch(currentMidi, chord, key, rangeInfo) {
        if (!chord) return currentMidi;
        const tonicPc = key.rootPc;
        const chordRootPc = chord.rootPc;
        const thirdInterval = chord.quality === 'maj' ? 4 : 3;
        const chordThirdPc = (chordRootPc + thirdInterval) % 12;
        let targetPcs;
        if (chordRootPc === tonicPc) {
            targetPcs = [tonicPc, chordThirdPc];
        } else {
            targetPcs = [chordRootPc, chordThirdPc];
        }
        return closestPitchToPcSet(currentMidi, targetPcs, rangeInfo);
    }

    function roundToGrid(value, grid = 0.25) {
        return Math.round(value / grid) * grid;
    }

    function isStrongBeat(beatInBar) {
        return Math.abs(beatInBar - 0) < 1e-3 || Math.abs(beatInBar - 2) < 1e-3;
    }

    function createRhythmPattern(totalBeats, density, { allowSyncopation }) {
        const pattern = [];
        let remaining = totalBeats;
        const densityKey = density === 'hook' ? 'dense' : density;
        const pools = {
            sparse: [1, 1, 0.5, 2],
            medium: [0.5, 1, 1, 0.75],
            dense: [0.5, 0.5, 0.25, 0.75, 1]
        };
        const source = pools[densityKey] || pools.medium;
        while (remaining > 1e-3) {
            let dur = source[Math.floor(Math.random() * source.length)];
            if (!allowSyncopation && Math.abs((totalBeats - remaining) % 1) > 1e-3 && dur === 0.25) {
                dur = 0.5;
            }
            if (remaining < 1) {
                dur = remaining;
            }
            dur = Math.max(0.25, Math.min(dur, remaining));
            pattern.push(roundToGrid(dur));
            remaining = roundToGrid(remaining - dur);
        }
        if (pattern.length) {
            pattern[pattern.length - 1] = roundToGrid(Math.max(pattern[pattern.length - 1], 1));
        }
        return pattern;
    }

    function createContourTargets(noteCount, contour, rangeInfo, energy = 1) {
        const targets = [];
        if (noteCount === 0) return targets;
        const min = rangeInfo ? rangeInfo.minMidi + 1 : 55;
        const max = rangeInfo ? rangeInfo.maxMidi - 1 : 80;
        const center = rangeInfo ? rangeInfo.centerMidi : (min + max) / 2;
        const span = clamp((max - min) * 0.8 * energy, 5, max - min);
        for (let i = 0; i < noteCount; i++) {
            const t = noteCount === 1 ? 0.5 : i / (noteCount - 1);
            let pos;
            switch (contour) {
                case 'rise':
                    pos = min + span * t;
                    break;
                case 'fall':
                    pos = max - span * t;
                    break;
                case 'wave':
                    pos = center + Math.sin(t * Math.PI * 2) * span * 0.35;
                    break;
                default:
                    pos = center + Math.sin(t * Math.PI) * span * 0.5;
                    break;
            }
            targets.push(pos + (Math.random() * 0.6 - 0.3));
        }
        return targets;
    }

    function buildRhythmFromBank(bankId, bars) {
        const bank = RHYTHM_BANKS[bankId];
        if (!bank || !bank.length) return null;
        const pattern = [];
        for (let i = 0; i < Math.max(1, bars); i++) {
            const barPattern = randomChoice(bank);
            pattern.push(...barPattern);
        }
        return pattern;
    }

    function composeMotif({ id, bars, contour, density, syncopated, rangeInfo, energy, patternBank }) {
        const beats = Math.max(1, bars) * 4;
        let rhythm = patternBank ? buildRhythmFromBank(patternBank, bars) : null;
        if (!rhythm || rhythm.length === 0) {
            rhythm = createRhythmPattern(beats, density, { allowSyncopation: !!syncopated });
        }
        const targets = createContourTargets(rhythm.length, contour, rangeInfo, energy);
        let cursor = 0;
        const notes = rhythm.map((dur, idx) => {
            const note = {
                start: roundToGrid(cursor),
                duration: dur,
                target: targets[idx],
                isCadence: idx === rhythm.length - 1,
                accent: isStrongBeat(cursor % 4)
            };
            cursor += dur;
            return note;
        });
        return {
            id,
            bars,
            beats,
            contour,
            notes
        };
    }

    function duplicateMotif(motif) {
        if (!motif) return null;
        return {
            ...motif,
            notes: motif.notes.map(n => ({ ...n }))
        };
    }

    function varyMotif(motif, rangeInfo, variation) {
        const clone = duplicateMotif(motif);
        if (!clone) return null;
        const last = clone.notes[clone.notes.length - 1];
        if (variation === 'tailLift' && last) {
            last.target = clamp(last.target + 2, rangeInfo.minMidi, rangeInfo.maxMidi);
        } else if (variation === 'answer') {
            clone.notes.forEach((note, idx) => {
                if (idx % 2 === 0) {
                    note.target = clamp(note.target - 1.5, rangeInfo.minMidi, rangeInfo.maxMidi);
                }
            });
        }
        return clone;
    }

    function getRangeForSection(section, rangeSelection, analysis) {
        const base = normalizeSectionKey(section.type);
        return (rangeSelection && rangeSelection[base]) || analysis.sectionRanges[base] || analysis.sectionRanges.verse;
    }

    function getMelodyBaseVelocity(sectionType, accent) {
        let base = 0.72;
        if (sectionType.startsWith('chorus')) base = 0.92;
        else if (sectionType.startsWith('pre')) base = 0.82;
        else if (sectionType.startsWith('verse')) base = 0.76;
        else if (sectionType === 'intro' || sectionType === 'outro') base = 0.65;
        else if (sectionType.startsWith('bridge')) base = 0.78;
        return clamp(base + (accent ? 0.06 : -0.02), 0.35, 1);
    }

    function renderMotifInstance({ motif, section, startBeat, rangeInfo, analysis, structure, partTag }) {
        if (!motif || !motif.notes || !motif.notes.length) return [];
        const { key, verseChords, chorusChords } = analysis;
        const sectionBeats = section.length * 4;
        const sectionStartBeat = section.startBar * 4;
        const notes = [];
        let prevMidi = null;
        motif.notes.forEach(note => {
            const absStart = startBeat + note.start;
            if (absStart >= sectionStartBeat + sectionBeats) return;
            const barIndex = Math.floor(absStart / 4);
            const chord = getChordAtBar(barIndex, structure, verseChords, chorusChords);
            const beatInBar = absStart - barIndex * 4;
            const strong = isStrongBeat(beatInBar);
            const sectionProgress = clamp((absStart - sectionStartBeat) / Math.max(1, sectionBeats), 0, 1);
            let midi = clampMidiToRange(note.target, rangeInfo);
            midi = refineNoteWithHarmony(midi, {
                key,
                chord,
                beatInBar,
                isCadence: note.isCadence,
                prevMidi,
                currMidi: midi,
                sectionType: section.type,
                isStrong: strong
            });
            if (note.isCadence) {
                midi = pickCadentialPitch(midi, chord, key, rangeInfo);
            }
            const dynMul = computeSectionVelocityMultiplier(section, 'melody', sectionProgress, strong);
            const velocity = clamp(getMelodyBaseVelocity(section.type, note.accent || strong) * dynMul, 0.35, 1);
            notes.push({
                midi,
                start: absStart,
                duration: note.duration,
                velocity,
                part: partTag
            });
            prevMidi = midi;
        });
        return notes;
    }

    function renderMotifSequence({ section, motifSequence, analysis, rangeInfo, structure, partTag }) {
        const results = [];
        if (!motifSequence || !motifSequence.length) return results;
        const sectionBeats = section.length * 4;
        const sectionStartBeat = section.startBar * 4;
        let cursor = 0;
        let idx = 0;
        while (cursor < sectionBeats - 0.25 && idx < 32) {
            const motif = motifSequence[idx % motifSequence.length];
            if (!motif) break;
            const motifBeats = motif.beats || (motif.notes[motif.notes.length - 1].start + motif.notes[motif.notes.length - 1].duration);
            results.push(
                ...renderMotifInstance({
                    motif,
                    section,
                    startBeat: sectionStartBeat + cursor,
                    rangeInfo,
                    analysis,
                    structure,
                    partTag
                })
            );
            cursor += motifBeats;
            idx++;
        }
        return results;
    }

    function createHookMotifSet({ hookBars, rangeInfo, songProfile, key }) {
        const profile = songProfile || selectIntentProfile();
        const bars = clamp(Math.round(hookBars) || 2, 2, 4);
        const energy = (profile.mood === 'intense' || profile.mood === 'epic') ? 1.15 : 0.95;
        const contourA = (profile.hookContours && profile.hookContours.length)
            ? randomChoice(profile.hookContours)
            : 'arch';
        const hookBias = profile.motifOptions?.hookRhythmBias || 'anthem';
        const hookPatternMap = {
            syncopated: 'syncopated',
            flow: 'lyric',
            anthem: 'busy',
            hook: 'busy'
        };
        const basePattern = hookPatternMap[hookBias] || 'busy';
        const base = composeMotif({
            id: 'hook_A',
            bars,
            contour: contourA,
            density: 'dense',
            syncopated: true,
            rangeInfo,
            energy,
            patternBank: basePattern
        });
        const clampTarget = (value) => Math.min(rangeInfo.maxMidi, Math.max(rangeInfo.minMidi, value));
        const variant = {
            ...base,
            id: 'hook_A_prime',
            notes: base.notes.map((n, idx) => ({
                ...n,
                target: clampTarget(n.target + (idx % 2 === 0 ? 1 : -1))
            }))
        };
        const contourB = (profile.hookContours && profile.hookContours.length > 1)
            ? randomChoice(profile.hookContours.filter(c => c !== contourA)) || 'rise'
            : 'rise';
        const secondaryPattern = profile.rhythmFlavor === 'half_time' ? 'syncopated' : 'busy';
        const contrast = composeMotif({
            id: 'hook_B',
            bars,
            contour: contourB,
            density: 'dense',
            syncopated: true,
            rangeInfo,
            energy: energy + 0.05,
            patternBank: secondaryPattern
        });
        let callResponse = null;
        if (profile.variationPolicy?.callResponseChance && Math.random() < profile.variationPolicy.callResponseChance) {
            callResponse = {
                ...variant,
                id: 'hook_C',
                notes: variant.notes.map((n, idx) => ({
                    ...n,
                    target: clampTarget(n.target + (idx % 3 === 0 ? -2 : 0.5))
                }))
            };
        }
        const set = { A: base, A_prime: variant, B: contrast };
        if (callResponse) set.C = callResponse;
        return set;
    }

    function generateMelodicMotifsForSections({
        structure,
        analysis,
        hookBars,
        density,
        rangeSelection,
        songProfile
    }) {
        const profile = songProfile || selectIntentProfile();
        const melodyNotes = [];
        const motifPlans = [];
        const chorusRange = rangeSelection.chorus || analysis.sectionRanges.chorus;
        const verseRange = rangeSelection.verse || analysis.sectionRanges.verse;
        const preRange = rangeSelection.pre || analysis.sectionRanges.pre;
        const introRange = rangeSelection.intro || analysis.sectionRanges.intro;
        const hookSet = createHookMotifSet({ hookBars, rangeInfo: chorusRange, songProfile: profile, key: analysis.key });

        const baseDensity = density || profile.userDensity || 'medium';
        const densityMap = profile.motifDensityMap || {};
        const getSectionDensity = (sectionType) => {
            const key = normalizeSectionKey(sectionType || '');
            return densityMap[key] || baseDensity;
        };

        const verseContour = resolveContourForSection(profile, 'verse');
        const versePatternBank = pickRhythmBankForSection(profile, 'verse', getSectionDensity('verse'));
        const verseMotifA = composeMotif({
            id: 'verse_A',
            bars: 2,
            contour: verseContour,
            density: getSectionDensity('verse'),
            syncopated: false,
            rangeInfo: verseRange,
            energy: 0.8,
            patternBank: versePatternBank
        });
        const verseMotifB = varyMotif(verseMotifA, verseRange, 'answer') || composeMotif({
            id: 'verse_B',
            bars: 2,
            contour: 'arch',
            density: getSectionDensity('verse'),
            syncopated: false,
            rangeInfo: verseRange,
            energy: 0.75,
            patternBank: versePatternBank
        });
        structure.forEach(section => {
            const rangeInfo = getRangeForSection(section, rangeSelection, analysis);
            const sectionDensity = getSectionDensity(section.type);
            let partTag = 'auto_hook_misc';
            if (section.type.startsWith('chorus')) partTag = 'auto_hook_chorus_main';
            else if (section.type.startsWith('pre')) partTag = 'auto_hook_pre';
            else if (section.type.startsWith('verse')) partTag = 'auto_hook_verse_main';
            else if (section.type === 'intro') partTag = 'auto_hook_intro';
            else if (section.type === 'outro') partTag = 'auto_hook_outro';

            if (section.type.startsWith('chorus')) {
                const barCount = Math.max(1, Math.round(section.length / 2));
                const labels = buildHookFormSequence(barCount, profile);
                const motifSequence = labels.map(label => hookSet[label] || hookSet.A);
                melodyNotes.push(...renderMotifSequence({
                    section,
                    motifSequence,
                    analysis,
                    rangeInfo: chorusRange,
                    structure,
                    partTag
                }));
                motifPlans.push({ section: section.type, motifs: labels });
            } else if (section.type.startsWith('verse')) {
                const motifSequence = [verseMotifA, verseMotifB];
                melodyNotes.push(...renderMotifSequence({
                    section,
                    motifSequence,
                    analysis,
                    rangeInfo,
                    structure,
                    partTag
                }));
                motifPlans.push({ section: section.type, motifs: motifSequence.map(m => (m && m.id) || 'verse') });
            } else if (section.type.startsWith('pre')) {
                const prePatternBank = pickRhythmBankForSection(profile, 'pre', sectionDensity);
                const preMotif = composeMotif({
                    id: 'pre',
                    bars: 1,
                    contour: resolveContourForSection(profile, 'pre'),
                    density: sectionDensity,
                    syncopated: true,
                    rangeInfo: preRange,
                    energy: 0.9,
                    patternBank: prePatternBank
                });
                melodyNotes.push(...renderMotifSequence({
                    section,
                    motifSequence: [preMotif],
                    analysis,
                    rangeInfo: preRange,
                    structure,
                    partTag
                }));
                motifPlans.push({ section: section.type, motifs: ['pre'] });
            } else if (section.type.startsWith('bridge')) {
                const bridgePattern = pickRhythmBankForSection(profile, 'bridge', sectionDensity);
                const bridgeMotif = composeMotif({
                    id: 'bridge',
                    bars: 2,
                    contour: resolveContourForSection(profile, 'bridge'),
                    density: sectionDensity,
                    syncopated: false,
                    rangeInfo,
                    energy: 0.7,
                    patternBank: bridgePattern
                });
                melodyNotes.push(...renderMotifSequence({
                    section,
                    motifSequence: [bridgeMotif],
                    analysis,
                    rangeInfo,
                    structure,
                    partTag
                }));
                motifPlans.push({ section: section.type, motifs: ['bridge'] });
            } else if (section.type === 'intro' || section.type === 'outro') {
                const introPattern = pickRhythmBankForSection(profile, section.type, sectionDensity);
                const motif = composeMotif({
                    id: section.type,
                    bars: 1,
                    contour: resolveContourForSection(profile, section.type),
                    density: sectionDensity,
                    syncopated: false,
                    rangeInfo: introRange,
                    energy: 0.6,
                    patternBank: introPattern
                });
                melodyNotes.push(...renderMotifSequence({
                    section,
                    motifSequence: [motif],
                    analysis,
                    rangeInfo: introRange,
                    structure,
                    partTag
                }));
                motifPlans.push({ section: section.type, motifs: [section.type] });
            }
        });
        return { motifPlans, melodyNotes };
    }

    function arrangeBassAndPads({ structure, analysis, genBass, genChords, profile }) {
        const arrangement = [];
        const bassRule = profile?.instrumentRules?.bass || (genBass ? 'full' : 'none');
        if (genBass && bassRule !== 'none') {
            arrangement.push(
                ...generateBassLineForStructure({
                    key: analysis.key,
                    structure,
                    verseChords: analysis.verseChords,
                    chorusChords: analysis.chorusChords,
                    profile
                })
            );
        }
        const padRule = profile?.instrumentRules?.pads || (genChords ? 'full' : 'none');
        if (genChords && padRule !== 'none') {
            arrangement.push(
                ...generatePadChordsForStructure({
                    key: analysis.key,
                    structure,
                    verseChords: analysis.verseChords,
                    chorusChords: analysis.chorusChords,
                    profile
                })
            );
        }
        return arrangement;
    }

    function pickBassPattern(sectionType, profile) {
        const behavior = profile?.bassBehavior || 'steady';
        const key = normalizeSectionKey(sectionType);
        if (behavior === 'pedal') {
            return key === 'chorus' ? 'drive' : 'pedal';
        }
        if (behavior === 'octave_drive') {
            return key === 'chorus' ? 'drive' : 'steady';
        }
        if (behavior === 'walking') {
            return key === 'verse' ? 'walking' : 'build';
        }
        if (behavior === '808_drops') {
            return key === 'chorus' ? '808' : 'pedal';
        }
        if (behavior === 'interval_jumps') {
            return key === 'chorus' ? 'interval' : 'drive';
        }
        if (sectionType.startsWith('chorus')) return 'drive';
        if (sectionType.startsWith('pre')) return 'build';
        if (sectionType.startsWith('bridge')) return 'pedal';
        if (sectionType === 'intro' || sectionType === 'outro') return 'pad';
        return behavior === 'drive' ? 'drive' : 'steady';
    }

    function chooseBassRegister(rootPc, prevMidi) {
        const candidates = [];
        for (let octave = 1; octave <= 4; octave++) {
            candidates.push(octave * 12 + rootPc);
        }
        if (prevMidi == null) return candidates[1];
        return candidates.reduce((best, cand) => {
            return Math.abs(cand - prevMidi) < Math.abs(best - prevMidi) ? cand : best;
        }, candidates[0]);
    }

    function generateBassLineForStructure({ key, structure, verseChords, chorusChords, profile }) {
        if (profile?.instrumentRules?.bass === 'none') return [];
        const notes = [];
        let prevRoot = null;
        let bassHasEntered = false;
        const firstPrimarySection = structure.find(sec =>
            sec.type &&
            (sec.type.startsWith('verse') ||
                sec.type.startsWith('chorus') ||
                sec.type.startsWith('pre') ||
                sec.type.startsWith('bridge'))
        );
        const bassEntryBar = firstPrimarySection ? firstPrimarySection.startBar : 0;

        structure.forEach(sec => {
            if (!shouldPlayInstrumentInSection(profile, 'bass', sec.type)) return;
            const secType = sec.type || '';
            const isPrimarySection =
                secType.startsWith('verse') ||
                secType.startsWith('chorus') ||
                secType.startsWith('pre') ||
                secType.startsWith('bridge');

            if (!bassHasEntered) {
                if (!isPrimarySection) {
                    return;
                }
                bassHasEntered = true;
            }

            for (let bar = sec.startBar; bar < sec.startBar + sec.length; bar++) {
                const chord = getChordAtBar(bar, structure, verseChords, chorusChords);
                if (!chord) continue;
                const barStart = bar * 4;
                const rootMidi = chooseBassRegister(chord.rootPc, prevRoot);
                const fifthMidi = rootMidi + 7;
                const octaveMidi = rootMidi + 12;
                const pattern = pickBassPattern(sec.type, profile);
                const barsSinceEntry = Math.max(0, bar - bassEntryBar);
                const entryFactor = Math.min(0.85, 0.3 + barsSinceEntry * 0.12);
                const sectionPad =
                    sec.type.startsWith('chorus') ? 0.85 :
                        sec.type.startsWith('pre') ? 0.78 :
                            sec.type.startsWith('verse') ? 0.65 :
                                0.55;
                const bassMasterAttenuation = 0.58;
                const sectionProgress = clamp((bar - sec.startBar) / Math.max(1, sec.length), 0, 1);
                const pushNote = (midi, offset, duration, velocity, accent) => {
                    const dyn = computeSectionVelocityMultiplier(sec, 'bass', sectionProgress, !!accent);
                    notes.push({
                        midi: clampMidiToRange(midi, { minMidi: 36, maxMidi: 72 }),
                        start: barStart + offset,
                        duration,
                        velocity: clamp(
                            velocity * dyn * entryFactor * sectionPad * bassMasterAttenuation,
                            0.18,
                            0.65
                        ),
                        part: 'auto_bass'
                    });
                };
                if (pattern === 'drive') {
                    pushNote(rootMidi, 0, 1, 0.66, true);
                    pushNote(fifthMidi, 1, 1, 0.56, false);
                    pushNote(octaveMidi, 2, 1, 0.6, true);
                    pushNote(rootMidi, 3, 1, 0.58, false);
                } else if (pattern === 'build') {
                    pushNote(rootMidi, 0, 1.5, 0.58, true);
                    pushNote(rootMidi + 2, 1.5, 0.5, 0.48, false);
                    pushNote(octaveMidi, 2, 1.5, 0.6, true);
                } else if (pattern === 'pedal') {
                    pushNote(rootMidi, 0, 4, 0.48, true);
                } else if (pattern === 'walking') {
                    const steps = [rootMidi, rootMidi + 2, rootMidi + (chord.quality === 'maj' ? 4 : 3), fifthMidi];
                    steps.forEach((m, idx) => pushNote(m, idx, 1, 0.52 + idx * 0.02, idx === 0 || idx === 2));
                } else if (pattern === '808') {
                    pushNote(rootMidi, 0, 3, 0.7, true);
                    pushNote(rootMidi - 5, 3, 1, 0.6, false);
                } else if (pattern === 'interval') {
                    pushNote(rootMidi, 0, 1.5, 0.64, true);
                    pushNote(rootMidi + 12, 1.5, 1, 0.55, true);
                    pushNote(rootMidi + 7, 2.5, 1.5, 0.58, false);
                } else if (pattern === 'pad') {
                    pushNote(rootMidi, 0, 4, 0.42, false);
                } else {
                    pushNote(rootMidi, 0, 2, 0.54, true);
                    pushNote(fifthMidi, 2, 2, 0.5, false);
                }
                prevRoot = rootMidi;
            }
        });
        return notes;
    }

    function generatePadChordsForStructure({ key, structure, verseChords, chorusChords, profile }) {
        if (profile?.instrumentRules?.pads === 'none') return [];
        const notes = [];
        const padRange = { minMidi: 60, maxMidi: 98 };
        let padHasEntered = false;
        const firstPrimarySection = structure.find(sec =>
            sec.type &&
            (sec.type.startsWith('verse') ||
                sec.type.startsWith('chorus') ||
                sec.type.startsWith('pre') ||
                sec.type.startsWith('bridge'))
        );
        const padEntryBar = firstPrimarySection ? firstPrimarySection.startBar : 0;
        const behavior = profile?.padBehavior || 'lush';

        structure.forEach(sec => {
            if (!shouldPlayInstrumentInSection(profile, 'pads', sec.type)) return;
            const secType = sec.type || '';
            const isPrimarySection =
                secType.startsWith('verse') ||
                secType.startsWith('chorus') ||
                secType.startsWith('pre') ||
                secType.startsWith('bridge');

            if (!padHasEntered) {
                if (!isPrimarySection) return;
                padHasEntered = true;
            }

            for (let bar = sec.startBar; bar < sec.startBar + sec.length; bar++) {
                if (bar < padEntryBar) continue;
                const chord = getChordAtBar(bar, structure, verseChords, chorusChords);
                if (!chord) continue;
                const barStart = bar * 4;
                const chordTones = getChordTonePcs(key, chord);
                if (!chordTones.length) continue;
                const baseOct = sec.type.startsWith('chorus') ? 5 : 4;
                let sustain = sec.type.startsWith('chorus') ? 4 : 2;
                if (behavior === 'stabs') sustain = 1.5;
                if (behavior === 'plucks') sustain = 1;
                const part = 'auto_pad';
                const sectionProgress = clamp((bar - sec.startBar) / Math.max(1, sec.length), 0, 1);
                const dynMul = computeSectionVelocityMultiplier(sec, 'pad', sectionProgress, false);
                let baseVelocity = sec.type.startsWith('chorus') ? 0.5 : 0.4;
                if (behavior === 'plucks') baseVelocity = 0.35;
                if (behavior === 'stacked') baseVelocity = 0.55;
                const velocity = clamp(baseVelocity * dynMul, 0.22, 0.55);

                chordTones.forEach((pc, voice) => {
                    const octaveOffset = voice >= 3 ? 1 : 0;
                    let octave = baseOct + octaveOffset;
                    if (voice === 0 && !sec.type.startsWith('chorus')) {
                        octave += 1; // keep root above mid register outside chorus
                    }
                    let midi = octave * 12 + pc;
                    midi = clampMidiToRange(midi, padRange);
                    notes.push({
                        midi,
                        start: barStart,
                        duration: sustain,
                        velocity,
                        part
                    });
                });

                if (sec.type.startsWith('chorus') || behavior === 'stacked') {
                    const highMidi = clampMidiToRange((baseOct + 1) * 12 + chordTones[0], padRange);
                    notes.push({
                        midi: highMidi,
                        start: barStart,
                        duration: sustain,
                        velocity: Math.max(0.25, velocity - 0.1),
                        part
                    });
                }
                if (behavior === 'plucks') {
                    notes.push({
                        midi: octaveMidiFromPc(chordTones[1], baseOct + 1),
                        start: barStart + 1.5,
                        duration: 0.5,
                        velocity: velocity + 0.05,
                        part: `${part}_accent`
                    });
                }
            }
        });
        return notes;

        function octaveMidiFromPc(pc, octave) {
            return clampMidiToRange(octave * 12 + pc, padRange);
        }
    }

    const DRUM_MIDI = {
        kick: 36,
        snare: 38,
        clap: 39,
        hat: 42,
        openHat: 46,
        tom: 45,
        crash: 49
    };

    function generateDrumPatterns({ structure, totalBars, grooveFlavor, hasLowEndSupport, firstActiveBeat, profile }) {
        if (profile?.instrumentRules?.drums === 'none') return [];
        const notes = [];
        const flavor = profile?.drumBehavior || grooveFlavor || randomChoice(['pop', 'edm', 'rock']);
        const activationBeat = Number.isFinite(firstActiveBeat) ? Math.max(0, firstActiveBeat) : 0;
        const silenceCutoff = activationBeat > 0 ? activationBeat - 0.5 : -Infinity;
        const kickThreshold = activationBeat > 0 ? activationBeat - 0.25 : 0;
        const addHit = (midi, start, velocity) => {
            notes.push({ midi, start, duration: 0.12, velocity: clamp(velocity, 0.3, 1), part: 'auto_drum' });
        };
        structure.forEach(sec => {
            if (!shouldPlayInstrumentInSection(profile, 'drums', sec.type)) return;
            for (let bar = sec.startBar; bar < sec.startBar + sec.length; bar++) {
                const barStart = bar * 4;
                 if (barStart + 0.01 < silenceCutoff) continue;
                 const allowKick = hasLowEndSupport && (kickThreshold <= 0 || barStart + 0.01 >= kickThreshold);
                 const placeKick = (offset, velocity) => {
                     if (!allowKick) return;
                     addHit(DRUM_MIDI.kick, barStart + offset, velocity);
                 };
                const role = (() => {
                    if (sec.type.startsWith('chorus')) return 'drive';
                    if (sec.type.startsWith('pre')) return 'build';
                    if (sec.type.startsWith('bridge')) return 'build';
                    if (sec.type.startsWith('verse')) return 'groove';
                    if (sec.type === 'intro' || sec.type === 'outro') return 'minimal';
                    return 'groove';
                })();
                if (role === 'minimal' || flavor === 'minimal') {
                    placeKick(0, 0.4);
                    addHit(DRUM_MIDI.snare, barStart + 2, 0.7);
                    addHit(DRUM_MIDI.hat, barStart, 0.5);
                    addHit(DRUM_MIDI.hat, barStart + 2, 0.5);
                } else if (role === 'groove') {
                    for (let i = 0; i < 4; i++) {
                        addHit(DRUM_MIDI.hat, barStart + i, flavor === 'rock' ? 0.55 : 0.48);
                        addHit(DRUM_MIDI.hat, barStart + i + 0.5, 0.4);
                    }
                    if (flavor === 'four_on_floor') {
                        placeKick(0, 0.72);
                        placeKick(1, 0.65);
                        placeKick(2, 0.7);
                        placeKick(3, 0.68);
                    } else {
                        placeKick(0, allowKick ? 0.65 : 0.4);
                        placeKick(flavor === 'rock' ? 1 : 1.5, allowKick ? 0.58 : 0.35);
                    }
                    const snareBeat = flavor === 'half_time' ? 3 : 2;
                    addHit(DRUM_MIDI.snare, barStart + snareBeat, 0.85);
                } else if (role === 'build') {
                    for (let i = 0; i < 8; i++) {
                        const hitMidi = flavor === 'shuffle' ? DRUM_MIDI.clap : DRUM_MIDI.tom;
                        addHit(hitMidi, barStart + i * 0.5, 0.65 + i * 0.03);
                    }
                    const snareBeat = flavor === 'half_time' ? 3 : 2;
                    addHit(DRUM_MIDI.snare, barStart + snareBeat, 0.9);
                } else if (role === 'drive') {
                    addHit(DRUM_MIDI.crash, barStart, 0.9);
                    for (let i = 0; i < 8; i++) {
                        let hatMidi = (i % 2 === 0) ? DRUM_MIDI.openHat : DRUM_MIDI.hat;
                        if (flavor === 'shuffle') hatMidi = DRUM_MIDI.hat;
                        addHit(hatMidi, barStart + i * 0.5, 0.62);
                    }
                    if (flavor === 'four_on_floor') {
                        [0, 1, 2, 3].forEach(beat => placeKick(beat, 0.74));
                    } else if (flavor === 'half_time') {
                        placeKick(0, 0.78);
                        placeKick(2.5, 0.68);
                    } else {
                        placeKick(0, allowKick ? 0.78 : 0.48);
                        placeKick(1, allowKick ? 0.7 : 0.42);
                        placeKick(3.25, allowKick ? 0.62 : 0.36);
                    }
                    const snareBeat = flavor === 'half_time' ? 3 : 2;
                    addHit(DRUM_MIDI.snare, barStart + snareBeat, 0.95);
                }
                if (flavor === 'shuffle') {
                    addHit(DRUM_MIDI.clap, barStart + 1.5, 0.6);
                }
            }
        });
        return notes;
    }

    function generateHookSpotlightHits(structure) {
        const notes = [];
        structure.forEach(sec => {
            if (!sec.type.startsWith('chorus')) return;
            const startBeat = sec.startBar * 4;
            notes.push({
                midi: DRUM_MIDI.crash,
                start: startBeat,
                duration: 0.4,
                velocity: 1,
                part: 'auto_drum_fx'
            });
            if (startBeat > 1) {
                notes.push({
                    midi: DRUM_MIDI.clap,
                    start: startBeat - 0.5,
                    duration: 0.15,
                    velocity: 0.85,
                    part: 'auto_drum_fx'
                });
            }
        });
        return notes;
    }

    function generateTransitionBridges({
        key,
        structure,
        verseChords,
        chorusChords,
        verseRangeInfo,
        chorusRangeInfo,
        profile
    }) {
        const bridges = [];
        if (!structure || structure.length <= 1) return bridges;

        const verseRange = verseRangeInfo || getRangeInfo(key, 'mid');
        const chorusRange = chorusRangeInfo || getRangeInfo(key, 'high');
        const defaultRange = getRangeInfo(key, 'mid');

        const totalDur = durations => durations.reduce((sum, d) => sum + d, 0);

        for (let idx = 0; idx < structure.length - 1; idx++) {
            const current = structure[idx];
            const next = structure[idx + 1];
            if (!next) continue;

            const boundaryBeat = next.startBar * 4;
            const sectionEndBeat = (current.startBar + current.length) * 4;
            if (boundaryBeat - current.startBar * 4 < 2 || boundaryBeat <= 0) continue;

            const enteringChorus = next.type.startsWith('chorus');
            const rangeInfo = enteringChorus ? (chorusRange || defaultRange) : (verseRange || defaultRange);
            let direction = enteringChorus ? 1 : -1;
            if (profile?.hookContours?.includes('fall') && enteringChorus && Math.random() < 0.3) {
                direction = -1;
            }
            const partTag = enteringChorus ? 'auto_transition_build' : 'auto_transition_release';
            const chord =
                getChordAtBar(next.startBar, structure, verseChords, chorusChords) ||
                getChordAtBar(Math.max(current.startBar, current.startBar + current.length - 1), structure, verseChords, chorusChords);

            const baseTargetPc = chord ? chord.rootPc : key.rootPc;
            const referenceMidi = clampMidiToRange(
                quantizeToScale(60 + baseTargetPc, key),
                rangeInfo
            );

            let durations = enteringChorus ? [0.25, 0.25, 0.5] : [0.5, 0.25, 0.25];
            if (profile?.rhythmFlavor === 'half_time') {
                durations = durations.map(d => d * 1.3);
            } else if (profile?.rhythmFlavor === 'double_time') {
                durations = durations.map(d => d * 0.8);
            }
            let startTime = boundaryBeat - totalDur(durations);
            startTime = Math.max(current.startBar * 4, Math.min(startTime, sectionEndBeat - totalDur(durations)));

            let steps = enteringChorus ? [-3, -1, 0] : [2, 1, 0];
            if (!enteringChorus && profile?.variationPolicy?.verseDrones) {
                steps = [0, -1, -2];
            }
            let cursor = startTime;
            steps.forEach((step, i) => {
                let midi = referenceMidi + step * direction;
                midi = quantizeToScale(midi, key);
                midi = clampMidiToRange(midi, rangeInfo);
                const velocity = enteringChorus ? 0.78 + i * 0.05 : 0.7 - i * 0.04;
                bridges.push({
                    midi,
                    start: cursor,
                    duration: durations[i],
                    velocity: clamp(velocity, 0.35, 1),
                    part: partTag
                });
                cursor += durations[i];
            });
        }

        return bridges;
    }
    function chooseOrnamentPitch(mainMidi, key, chord, rangeInfo) {
        const workingRange = rangeInfo || getRangeInfo(key, 'mid');
        const clampPitch = midi => clampMidiToRange(midi, workingRange);
        const candidates = new Set();
        const push = midi => {
            if (midi == null) return;
            const clamped = clampPitch(midi);
            if (Math.abs(clamped - mainMidi) < 0.25) return;
            candidates.add(clamped);
        };

        const scalePcs = key.scalePcs || key.scaleSets.major || [];
        const chordTones = chord ? getChordTonePcs(key, chord) : [];
        const tensions = chord ? getAllowedTensionsPcs(key, chord, chordTones) : [];

        [-2, -1, 1, 2].forEach(step => {
            const diatonic = quantizeToScale(mainMidi + step, key);
            push(diatonic);
        });

        [-1, 1].forEach(semi => push(mainMidi + semi));

        chordTones.forEach(pc => {
            const octave = Math.floor(mainMidi / 12);
            for (let o = octave - 1; o <= octave + 1; o++) {
                push(o * 12 + pc);
            }
        });

        const scoreCandidate = midi => {
            const pc = ((midi % 12) + 12) % 12;
            let score = -Math.abs(midi - mainMidi);
            if (chordTones.includes(pc)) score += 2;
            else if (tensions.includes(pc)) score += 1.2;
            else if (scalePcs.includes(pc)) score += 0.6;
            const dir = midi > mainMidi ? 1 : -1;
            score += dir * 0.2;
            return score;
        };

        const list = Array.from(candidates);
        if (!list.length) return clampPitch(mainMidi + 1);
        list.sort((a, b) => scoreCandidate(b) - scoreCandidate(a));
        return list[0];
    }

    // === Melody ornaments: neighbor & passing approaches ===
    function addMelodicOrnaments(
        melodyNotes,
        { key, structure, verseChords, chorusChords, rangeInfo, ornamentDensity, ornamentDuration, profile }
    ) {
        const res = [];
        const sorted = melodyNotes.slice().sort((a, b) => a.start - b.start);
        const complexityMod =
            profile?.motifComplexity === 'minimal' ? 0.6 :
                profile?.motifComplexity === 'busy' ? 1.15 : 1;
        const density = (ornamentDensity != null ? ornamentDensity : 0.25) * complexityMod;
        const baseOrnDur = ornamentDuration || ORNAMENT_NOTE_DURATION;
        const range = rangeInfo || getRangeInfo(key, 'mid');

        const getNoteEnd = (note) => note.start + note.duration;

        sorted.forEach((n, idx) => {
            res.push(n);

            const sec = getSectionForBeat(structure, n.start);
            if (!sec) return;

            const secType = sec.type || '';
            if (profile?.variationPolicy?.sustainFirstVerse && secType.startsWith('verse1')) {
                if (Math.random() < 0.8) return;
            }
            const activeSection =
                secType.startsWith('verse') ||
                secType.startsWith('pre') ||
                secType.startsWith('chorus');

            if (!activeSection) return;
            if (n.duration < 0.45) return;
            if (Math.random() >= density) return;

            const beatPos = ((n.start % 4) + 4) % 4;
            const isStrong =
                Math.abs(beatPos - 0) < 1e-3 ||
                Math.abs(beatPos - 2) < 1e-3;
            if (!isStrong && Math.random() > 0.4) return;

            const prev = idx > 0 ? sorted[idx - 1] : null;
            const next = idx + 1 < sorted.length ? sorted[idx + 1] : null;
            const sectionStartBeat = sec.startBar * 4;
            const sectionEndBeat = (sec.startBar + sec.length) * 4;

            const noteStart = n.start;
            const noteEnd = getNoteEnd(n);
            const prevEnd = prev ? getNoteEnd(prev) : -Infinity;
            const nextStart = next ? next.start : Infinity;
            const gapBefore = noteStart - prevEnd;
            const gapAfter = nextStart - noteEnd;

            const minGapBefore = Math.max(0.12, baseOrnDur * 0.8);
            const minGapAfter = Math.max(0.12, baseOrnDur * 0.7);

            const barIndex = Math.floor(noteStart / 4);
            const chord = getChordAtBar(barIndex, structure, verseChords, chorusChords);

            const canBefore = gapBefore > minGapBefore && (noteStart - baseOrnDur) >= sectionStartBeat - 1e-3;
            const canBetween =
                gapAfter > minGapAfter &&
                noteEnd + baseOrnDur <= nextStart - 0.02 &&
                (nextStart <= sectionEndBeat + 1e-3);
            const canTail = !canBetween && (n.duration > baseOrnDur + 0.08);

            if (!canBefore && !canBetween && !canTail) return;

            let placement;
            if (canBetween && canBefore) placement = Math.random() < 0.5 ? 'before' : 'between';
            else if (canBetween) placement = 'between';
            else if (canTail) placement = 'tail';
            else placement = 'before';
            if (profile?.rhythmFlavor === 'half_time' && placement === 'between' && Math.random() < 0.4) {
                placement = 'before';
            }

            let ornDuration = baseOrnDur;
            let ornStart;

            if (placement === 'before') {
                const available = Math.min(gapBefore, baseOrnDur * 1.2);
                ornDuration = Math.max(0.08, Math.min(baseOrnDur, available));
                ornStart = Math.max(sectionStartBeat, noteStart - ornDuration - 0.01);
            } else if (placement === 'between') {
                const available = gapAfter;
                ornDuration = Math.min(baseOrnDur, available * 0.9);
                ornStart = noteEnd + (available - ornDuration) * 0.4;
                if (ornStart + ornDuration > nextStart) {
                    ornStart = nextStart - ornDuration - 0.01;
                }
            } else {
                // tail ornament sits inside the sustaining note
                ornDuration = Math.min(baseOrnDur, n.duration * 0.4);
                ornStart = Math.max(noteStart, noteEnd - ornDuration - 0.01);
            }

            if (ornStart < sectionStartBeat - 1e-4) return;
            if (ornStart + ornDuration > sectionEndBeat + 1e-4) return;

            const sectionBeats = Math.max(1, sectionEndBeat - sectionStartBeat);
            const ornamentProgress = Math.min(1, Math.max(0, (ornStart - sectionStartBeat) / sectionBeats));
            const dynMul = computeSectionVelocityMultiplier(sec, 'ornament', ornamentProgress, isStrong);

            const ornMidi = chooseOrnamentPitch(n.midi, key, chord, range);
            const anchorVel = Math.max(
                0.25,
                Math.min(1, n.velocity * (placement === 'before' ? 0.82 : 0.88))
            );
            const velocityBias =
                profile?.ornamentBias?.velocityMul ||
                (profile?.motifComplexity === 'busy' ? 1.05 : 1);
            const ornVelocity = Math.max(0.2, Math.min(1, anchorVel * dynMul * velocityBias));
            const orn = {
                midi: ornMidi,
                start: ornStart,
                duration: ornDuration,
                velocity: ornVelocity,
                part: (n.part || 'auto_hook') + '_orn'
            };
            res.push(orn);
        });

        return res.sort((a, b) => a.start - b.start);
    }
    // === Section pickup notes ===
    function addSectionPickups(melodyNotes, key, structure, profile) {
        const result = melodyNotes.slice();
        const byStart = melodyNotes.slice().sort((a, b) => a.start - b.start);

        structure.forEach(sec => {
            if (!(sec.type.startsWith('verse') || sec.type.startsWith('chorus'))) return;
            if (sec.startBar === 0) return;

            const sectionStart = sec.startBar * 4;
            const firstNote = byStart.find(n => n.start >= sectionStart && n.start < sectionStart + 2);
            if (!firstNote) return;

            const hasPickup = byStart.some(n =>
                n.start >= sectionStart - 0.5 && n.start < sectionStart && (n.part || '').includes('pickup')
            );
            if (hasPickup) return;

            const pickupStart = sectionStart - 0.5;
            if (pickupStart < 0) return;
            if (profile?.motifComplexity === 'minimal' && Math.random() < 0.5) return;

            const baseMidi = firstNote.midi;
            const pickupMidi = quantizeToScale(baseMidi + (Math.random() < 0.5 ? -2 : -1), key);

            result.push({
                midi: pickupMidi,
                start: pickupStart,
                duration: 0.5 - ORNAMENT_NOTE_DURATION,
                velocity: Math.max(0.4, firstNote.velocity * 0.8),
                part: 'auto_hook_pickup'
            });
        });

        return result.sort((a, b) => a.start - b.start);
    }

    // === Chorus octave doubling ===
    function addChorusOctaveDoubling(melodyNotes, structure, profile) {
        const extra = [];
        melodyNotes.forEach(n => {
            const sec = getSectionForBeat(structure, n.start);
            if (!sec || !sec.type.startsWith('chorus')) return;
            if (!n.part || !n.part.includes('chorus_main')) return;
            if (n.duration < 0.5) return;
            const chance = profile?.variationPolicy?.hookOctaveChance != null
                ? profile.variationPolicy.hookOctaveChance
                : 0.35;
            if (Math.random() > chance) return;
            const hiMidi = n.midi + 12;
            if (hiMidi > 96) return;
            extra.push({
                ...n,
                midi: hiMidi,
                velocity: Math.max(0.35, n.velocity * 0.7),
                part: n.part + '_oct'
            });
        });
        return melodyNotes.concat(extra).sort((a, b) => a.start - b.start);
    }

    // === Chorus phrase-end fills ===
    function addPhraseEndFills(melodyNotes, key, structure, profile) {
        const result = melodyNotes.slice();
        const extra = [];

        structure.forEach(sec => {
            if (!sec.type.startsWith('chorus')) return;
            const secStart = sec.startBar * 4;
            const secEnd = (sec.startBar + sec.length) * 4;
            const lastBeatStart = secEnd - 1;

            const notesInLastBeat = melodyNotes.filter(n => n.start >= lastBeatStart && n.start < secEnd);
            if (notesInLastBeat.length > 0) return;
            if (profile?.motifComplexity === 'minimal' && Math.random() < 0.6) return;

            const secNotes = melodyNotes.filter(n => n.start >= secStart && n.start < secEnd);
            if (!secNotes.length) return;

            const anchor = secNotes.reduce((a, b) => a.start >= b.start ? a : b);
            let curStart = secEnd - 1.5;
            let curMidi = anchor.midi;
            const stepDur = 0.5;

            for (let i = 0; i < 3; i++) {
                if (curStart >= secEnd) break;
                curMidi = quantizeToScale(curMidi - 2, key);
                extra.push({
                    midi: curMidi,
                    start: curStart,
                    duration: stepDur,
                    velocity: Math.min(1, anchor.velocity * 0.9),
                    part: 'auto_hook_fill'
                });
                curStart += stepDur;
            }
        });

        return result.concat(extra).sort((a, b) => a.start - b.start);
    }

    function postProcessMelody(
        melodyNotes,
        {
            key,
            structure,
            verseChords,
            chorusChords,
            verseRangeInfo,
            chorusRangeInfo,
            ornamentDensity = 0.28,
            ornamentDuration = ORNAMENT_NOTE_DURATION,
            profile
        }
    ) {
        let res = melodyNotes;

        const rangeInfoForOrn =
            chorusRangeInfo ||
            verseRangeInfo ||
            getRangeInfo(key, 'mid');

        res = addMelodicOrnaments(res, {
            key,
            structure,
            verseChords,
            chorusChords,
            rangeInfo: rangeInfoForOrn,
            ornamentDensity,
            ornamentDuration,
            profile
        });

        res = addSectionPickups(res, key, structure, profile);
        res = addChorusOctaveDoubling(res, structure, profile);
        res = addPhraseEndFills(res, key, structure, profile);

        return res;
    }


    function generateSongMelodies({ key, verseChords, chorusChords, hookBars, totalBars, density, range, genBass, genChords, songProfile }) {
        const profile = songProfile || buildSongProfile({
            density,
            range,
            hookBars,
            totalBars,
            genBass,
            genChords
        });
        const decoratedChorus = decorateChorusChords(chorusChords, key, profile);
        const analysis = analyzeKeyAndChords({
            key,
            verseChords,
            chorusChords: decoratedChorus.length ? decoratedChorus : chorusChords
        });
        const structure = buildSongStructurePlan(totalBars, hookBars, profile);
        applyIntentToStructure(structure, profile);

        const desiredRange = profile.userRange || range || 'mid';
        const chorusRange = getRangeInfo(key, desiredRange);
        const rangeSelection = {
            intro: analysis.sectionRanges.intro,
            verse: analysis.sectionRanges.verse,
            pre: analysis.sectionRanges.pre,
            chorus: chorusRange,
            bridge: analysis.sectionRanges.bridge,
            outro: analysis.sectionRanges.outro
        };

        const { melodyNotes: draftMelody } = generateMelodicMotifsForSections({
            structure,
            analysis,
            hookBars,
            density,
            rangeSelection,
            songProfile: profile
        });

        const ornamentDensity = (profile.ornamentBias && profile.ornamentBias.density) || 0.28;
        const ornamentDuration = (profile.ornamentBias && profile.ornamentBias.duration) || ORNAMENT_NOTE_DURATION;

        const processedMelody = postProcessMelody(draftMelody, {
            key,
            structure,
            verseChords: analysis.verseChords,
            chorusChords: analysis.chorusChords,
            verseRangeInfo: rangeSelection.verse,
            chorusRangeInfo: rangeSelection.chorus,
            ornamentDensity,
            ornamentDuration,
            profile
        });

        const arrangementNotes = arrangeBassAndPads({
            structure,
            analysis,
            genBass,
            genChords,
            profile
        });

        const earliestMelodyBeat = processedMelody.length
            ? processedMelody.reduce((min, n) => Math.min(min, n.start), Infinity)
            : Infinity;
        const earliestArrangementBeat = arrangementNotes.length
            ? arrangementNotes.reduce((min, n) => Math.min(min, n.start), Infinity)
            : Infinity;
        const firstActiveBeat = Math.min(earliestMelodyBeat, earliestArrangementBeat);

        const grooveFlavor = profile.grooveFlavor || randomChoice(['pop', 'edm', 'rock']);
        arrangementNotes.push(
            ...generateDrumPatterns({
                structure,
                totalBars,
                grooveFlavor,
                hasLowEndSupport: genBass || genChords,
                firstActiveBeat: Number.isFinite(firstActiveBeat) ? firstActiveBeat : 0,
                profile
            }),
            ...generateHookSpotlightHits(structure)
        );

        const transitionNotes = generateTransitionBridges({
            key,
            structure,
            verseChords: analysis.verseChords,
            chorusChords: analysis.chorusChords,
            verseRangeInfo: rangeSelection.verse,
            chorusRangeInfo: rangeSelection.chorus,
            profile
        });

        const melodyWithTransitions = processedMelody.concat(transitionNotes);
        const normalizedMelody = normalizeAutoNoteDynamics(melodyWithTransitions, structure, profile);
        const normalizedArrangement = normalizeAutoNoteDynamics(arrangementNotes, structure, profile);

        return {
            melodyNotes: normalizedMelody,
            arrangementNotes: normalizedArrangement
        };
    }

    function applyAutoComposition(melodyNotes, arrangementNotes) {
        STATE.notes = STATE.notes.filter(n => !(n.part && n.part.startsWith('auto_')));

        const allNew = [...melodyNotes, ...arrangementNotes];
        allNew.forEach(n => {
            const row = getRowFromMidi(n.midi);
            STATE.notes.push({
                id: generateNoteId(),
                row,
                start: n.start,
                duration: n.duration,
                velocity: n.velocity,
                part: n.part
            });
        });

        drawNotes();
        drawVelocityLane();
        syncTransport();
        STATE.hasPendingHistorySnapshot = true;
        captureHistorySnapshot();
    }

    function normalizeProgressString(str) {
        return str.replace(/\s+/g, ' ').trim();
    }

    const MAJOR_VERSE_PRESETS = [
        "I | V | vi | IV",
        "I | IV | V | I",
        "vi | IV | I | V",
        "I | V | IV | V",
        "I | iii | vi | IV"
    ];

    const MAJOR_CHORUS_PRESETS = [
        "I | V | vi | IV",
        "I | V | IV | V",
        "I | iii | vi | IV",
        "IV | V | I",
        "I | V | vi | iii | IV | I | IV | V"
    ];

    const MINOR_VERSE_PRESETS = [
        "i | VI | III | VII",
        "i | VII | VI | VII",
        "i | iv | VI | VII",
        "i | v | VI | III"
    ];

    const MINOR_CHORUS_PRESETS = [
        "i | VI | III | VII",
        "i | VII | VI | VII",
        "i | III | VII | VI",
        "i | iv | VI | VII | i"
    ];

    function randomFunctionalProgression(key, isChorus) {
        const mode = key.mode;

        const usePreset = Math.random() < (isChorus ? 0.6 : 0.4);
        if (usePreset) {
            if (mode === 'major') {
                return (isChorus ? randomChoice(MAJOR_CHORUS_PRESETS) : randomChoice(MAJOR_VERSE_PRESETS));
            } else {
                return (isChorus ? randomChoice(MINOR_CHORUS_PRESETS) : randomChoice(MINOR_VERSE_PRESETS));
            }
        }

        const T = (mode === 'major') ? ['I', 'vi', 'iii'] : ['i', 'VI', 'III'];
        const P = (mode === 'major') ? ['ii', 'IV'] : ['ii', 'iv', 'VI'];
        const D = (mode === 'major') ? ['V'] : ['V', 'VII'];

        const funcMap = new Map();
        T.forEach(n => funcMap.set(n, 'T'));
        P.forEach(n => funcMap.set(n, 'P'));
        D.forEach(n => funcMap.set(n, 'D'));

        const minLen = isChorus ? 4 : 3;
        const maxLen = isChorus ? 8 : 6;
        const len = randomInt(minLen, maxLen);

        const seq = [];

        for (let i = 0; i < len; i++) {
            if (i === 0) {
                seq.push(randomChoice(T));
            } else if (i === len - 1) {
                const lastFunc = Math.random() < 0.7 ? 'T' : 'D';
                const pool = lastFunc === 'T' ? T : D;
                seq.push(randomChoice(pool));
            } else {
                const prev = seq[i - 1];
                const prevF = funcMap.get(prev) || 'T';
                let pool;
                if (prevF === 'T') {
                    pool = P.concat(T, D);
                } else if (prevF === 'P') {
                    pool = D.concat(T, P);
                } else {
                    pool = T.concat(P, D);
                }
                const uniq = Array.from(new Set(pool));
                seq.push(randomChoice(uniq));
            }
        }

        if (isChorus && seq.length <= maxLen - 2 && Math.random() < 0.4) {
            seq.push('V');
            seq.push(mode === 'major' ? 'I' : 'i');
        }

        return seq.join(' | ');
    }

    function autoGenerateFromUI() {
        try {
            const keyRoot = autoEls.keyRoot.value || 'C';
            const keyMode = autoEls.keyMode.value || 'major';
            let verseChordStr = autoEls.verseChords.value || DEFAULT_VERSE_PROGRESS;
            let chorusChordStr = autoEls.chorusChords.value || DEFAULT_CHORUS_PROGRESS;
            const hookBars = Math.max(1, (parseInt(autoEls.hookBars.value || '4', 10) || 4));
            let totalBars = parseInt(autoEls.totalBars.value || '0', 10) || 0;
            const density = autoEls.density.value || 'dense';
            const range = autoEls.range.value || 'mid';
            const genBass = autoEls.genBass.checked;
            const genChords = autoEls.genChords.checked;

            const key = parseKey(keyRoot, keyMode);
            let verseChords = parseChordProgression(verseChordStr, key);
            let chorusChords = parseChordProgression(chorusChordStr, key);

            if (normalizeProgressString(verseChordStr) === normalizeProgressString(DEFAULT_VERSE_PROGRESS)) {
                verseChords = mutateChordSequence(verseChords, key, 'verse');
                autoEls.verseChords.value = chordSequenceToString(verseChords);
            }
            if (normalizeProgressString(chorusChordStr) === normalizeProgressString(DEFAULT_CHORUS_PROGRESS)) {
                chorusChords = mutateChordSequence(chorusChords, key, 'chorus');
                autoEls.chorusChords.value = chordSequenceToString(chorusChords);
            }

            if (verseChords.length === 0 || chorusChords.length === 0) {
                alert('Verse or Chorus chord progression is empty/invalid.');
                return;
            }

            if (!totalBars || totalBars <= 0) {
                totalBars = 90;
            }
            totalBars = Math.max(8, Math.min(180, totalBars));
            autoEls.totalBars.value = totalBars;

            CONFIG.totalMeasures = totalBars;
            recalcWorldDimensions();
            resizeOverlayCanvases();

            const songProfile = buildSongProfile({
                density,
                range,
                hookBars,
                totalBars,
                genBass,
                genChords
            });
            STATE.currentIntent = songProfile;

            const { melodyNotes, arrangementNotes } = generateSongMelodies({
                key,
                verseChords,
                chorusChords,
                hookBars,
                totalBars,
                density,
                range,
                genBass,
                genChords,
                songProfile
            });

            applyAutoComposition(melodyNotes, arrangementNotes);
        } catch (err) {
            console.error(err);
            alert('Auto compose failed: ' + err.message);
        }
    }

    autoEls.generateBtn.addEventListener('click', autoGenerateFromUI);

    function randomizeAutoParams() {
        const roots = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
        const mode = Math.random() < 0.6 ? 'major' : 'minor';
        const root = randomChoice(roots);

        autoEls.keyRoot.value = root;
        autoEls.keyMode.value = mode;

        const key = parseKey(root, mode);

        const verseProgStr = randomFunctionalProgression(key, false);
        const chorusProgStr = randomFunctionalProgression(key, true);

        autoEls.verseChords.value = verseProgStr;
        autoEls.chorusChords.value = chorusProgStr;

        const hookOptions = [1, 2, 4];
        autoEls.hookBars.value = randomChoice(hookOptions);

        const totalBars = randomInt(32, 128);
        autoEls.totalBars.value = totalBars;

        const densities = ['sparse', 'medium', 'dense'];
        autoEls.density.value = randomChoice(densities);

        const ranges = ['low', 'mid', 'high'];
        autoEls.range.value = randomChoice(ranges);

        autoEls.genBass.checked = Math.random() < 0.9;
        autoEls.genChords.checked = Math.random() < 0.9;
    }

    autoEls.randomBtn.addEventListener('click', randomizeAutoParams);
</script>
</body>
</html>
